<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>老逸的个人站</title><link href="/" rel="alternate"></link><link href="http://www.scutlaoyi.tk/feeds/linux.atom.xml" rel="self"></link><id>/</id><updated>2014-10-24T18:30:00+08:00</updated><entry><title>Arch Linux升级笔记</title><link href="/arch_upgrade_note.html" rel="alternate"></link><updated>2014-10-24T18:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-10-24:arch_upgrade_note.html</id><summary type="html">&lt;p&gt;花了半天时间升级了自家的Arch Linux，
状况百出，
记录一下处理的流程。&lt;/p&gt;
&lt;p&gt;自从用上公司发的笔记本后自己的本子就不怎么玩了，
主要是ssd忒爽，
而且玩坏了有保修，
不用自己管～&lt;/p&gt;
&lt;div class="section" id="pacman"&gt;
&lt;h2&gt;pacman的自动更新&lt;/h2&gt;
&lt;p&gt;直接跑命令就可以了，
pacman -Syu，
下载了几百兆的新东西，
安装了几十分钟。&lt;/p&gt;
&lt;p&gt;重启后内核从3.14升级到3.17最新版。&lt;/p&gt;
&lt;p&gt;貌似更换了部分驱动，
用起来没什么感觉。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="openbox"&gt;
&lt;h2&gt;openbox故障&lt;/h2&gt;
&lt;p&gt;博主的桌面环境是lxde，
重启后进桌面什么都没有，
只有一团黑布和一个鼠标的指针。&lt;/p&gt;
&lt;p&gt;试了一下发现右键可以打开openbox菜单，
快捷键也可以开启各种应用，
初步断定openbox运行正常，
只是panel没有正确启动而已。&lt;/p&gt;
&lt;p&gt;在官网上找到下面的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/LXDE#Changes_to_desktop.conf_with_lxsession_1:0.5.1-1"&gt;https://wiki.archlinux.org/index.php/LXDE#Changes_to_desktop.conf_with_lxsession_1:0.5.1-1&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;于是改了配置，
重启，
熟悉的桌面就回来了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="dnscrypt-proxy"&gt;
&lt;h2&gt;dnscrypt_proxy故障&lt;/h2&gt;
&lt;p&gt;发现dnscrypt_proxy启动失败，
查了输出发现丢失几个奇怪的库文件，
但查了一下系统发现库是在的。&lt;/p&gt;
&lt;p&gt;搞了几下没搞定，
直接把dnscrypt_proxy删了。&lt;/p&gt;
&lt;p&gt;由于是源码编译安装，
直接跑到二进制文件的目录里把它干掉了事。&lt;/p&gt;
&lt;p&gt;本地的unbound修改了转发规则，
直接把dns请求发到openDNS服务器上去。&lt;/p&gt;
&lt;p&gt;这么做的目的其实是dnscrypt对博主来说用处不大。&lt;/p&gt;
&lt;p&gt;dnscrypt_proxy的功能是可以提供无污染的dns解析结果，
对于某些被dns污染的URL有抵抗作用。
本地再使用unbound进行dns缓存加速解析。&lt;/p&gt;
&lt;p&gt;但由于已经直接配置了根据域名的代理转发，
被墙的网站都走代理线路，
对目标URL的访问根本不会进行本地dns解析，
因此也就不需要dnscrypt进行防污染了。&lt;/p&gt;
&lt;p&gt;而且现在貌似通过DNS污染进行干扰的东西越来越少，
都是直接封ip了。&lt;/p&gt;
&lt;p&gt;另外一个dns相关的是unbound，
功能是一层本地的dns服务器，
配置之后本地进行dns查询结果的缓存，
当有dns请求时优先查缓存，
没有的话再发请求到远端的dns服务器。&lt;/p&gt;
&lt;p&gt;本地需要配置dns服务器为unbound的监听地址。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="chromium"&gt;
&lt;h2&gt;chromium的安装&lt;/h2&gt;
&lt;p&gt;其实Firefox各方面都非常好用，
但由于垃圾Flash的原因，
有时候看视频有点麻烦。&lt;/p&gt;
&lt;p&gt;听说Chrome系列在linux下的Flash比较完善，
于是狠心花了几十兆的空间装了个Chromium。&lt;/p&gt;
&lt;p&gt;然后就出问题了，
Chromium无法启动，
一直显示permission deny。&lt;/p&gt;
&lt;p&gt;追查到最后发现是配置文件读取失败，
由于pacman的调用需要root权限，
因此每次安装或者执行程序的升级操作都是切到root帐号，
平常使用的是普通的帐号。&lt;/p&gt;
&lt;p&gt;很奇怪的就是chromium安装完成后在普通帐号的home目录下创建的config文件夹，
居然是root账户创建的，
因此切换回普通账户后由于config文件夹不是自己所有，
一直访问失败。&lt;/p&gt;
&lt;p&gt;知道原因后处理也就很简单了，
切换到root更新一下config目录的所有者即可：&lt;/p&gt;
&lt;blockquote&gt;
chown -R normal:normal /home/normal/.config/chromium&lt;/blockquote&gt;
&lt;p&gt;对于其他一些程序，
如果安装完成后发现无法启动，
也可以观察一下是否配置文件的权限有问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="chromiumflashpepper-flash"&gt;
&lt;h2&gt;Chromium中Flash插件pepper-flash的安装&lt;/h2&gt;
&lt;p&gt;这货居然是在AUR中，
博主一直绕过AUR方面的操作，
因为自己太懒，
感觉需要自行编译打包实在麻烦。&lt;/p&gt;
&lt;p&gt;没想到今天还是没法绕过这块东西，
不过学了一下发现其实也不难。&lt;/p&gt;
&lt;p&gt;问题却主要出在网络连接上。&lt;/p&gt;
&lt;p&gt;根据Arch官方的文档，
AUR仓库中包的安装主要有如下几步：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1、首先需要安装必须的编译和打包工具：pacman -S --needed base-devel
2、去到目标包的首页点击下载tar包
3、解压目标tar包：tar -xvf foo.tar.gz
4、进去解压出来的目录，跑一趟makepkg，自动下载编译并打包所需的包
5、调用pacman安装最终生成的目标包：pacman -U bar.tar.xz
&lt;/pre&gt;
&lt;p&gt;注意的是如果makepkg出来的src目录里有readme的话，
需要先看一下readme，
防止后续的安装出错。&lt;/p&gt;
&lt;p&gt;对于pepper-flash，
则直接走一遍上述流程即可。&lt;/p&gt;
&lt;p&gt;然后坑爹的事情来了，
博主跑makepkg的时候一直下载源代码失败，
感觉就像是被墙了一样。&lt;/p&gt;
&lt;p&gt;于是开启全局http代理走goagent：&lt;/p&gt;
&lt;blockquote&gt;
export http_proxy=127.0.0.1:8087&lt;/blockquote&gt;
&lt;p&gt;发现没有效果，
才知道原来这个是https。&lt;/p&gt;
&lt;blockquote&gt;
export https_proxy=127.0.0.1:8087&lt;/blockquote&gt;
&lt;p&gt;然后报证书错误，
原来博主没有导入goa的假证书到系统里，
因为一直用Firefox什么问题都没有。&lt;/p&gt;
&lt;p&gt;想想不如走socks5代理算了，
pacman装了一个转发应用网络请求到socks代理的工具：&lt;/p&gt;
&lt;blockquote&gt;
pacman -S proxychains-ng&lt;/blockquote&gt;
&lt;p&gt;更改了配置文件，
走本地的shadowsocks代理，
执行makepkg&lt;/p&gt;
&lt;blockquote&gt;
proxychains makepkg&lt;/blockquote&gt;
&lt;p&gt;报错...&lt;/p&gt;
&lt;p&gt;没办法，
最后导入goa的假证书再更新系统证书解决问题：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1、复制CA.crt到/usr/local/share/ca-certificates/goa.crt
2、执行命令： update-ca-certificates
&lt;/pre&gt;
&lt;p&gt;如果没有操作一的目标目录就自己创建个。&lt;/p&gt;
&lt;p&gt;至此，
pepper-flash插件终于装完，
博主的升级之旅也就结束了。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="Arch"></category></entry><entry><title>screen混搭shell实现自动化工具</title><link href="/Bash005_auto_shell_and_screen.html" rel="alternate"></link><updated>2014-08-27T11:00:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-08-27:Bash005_auto_shell_and_screen.html</id><summary type="html">&lt;p&gt;博主最近应用了许多强悍的网络辅助工具，
大部分是Python程序及shell脚本，
一个shadowsocks，一个goagent，还有一个DNScrypt。
这些工具的特点是在正常的情况下可以无视，
而在网络异常时（google上不去）则需要查看输出是否工作正常，
必要时需要手动配置和重启。&lt;/p&gt;
&lt;p&gt;因此既需要工具界面不太占用地方（最好能全部缩在同个界面里），
又需要非常方便地调出输出记录观察工作情况。&lt;/p&gt;
&lt;p&gt;为了方便使用和管理，
博主自造了若干shell脚本用于便捷启动，
同时用screen将三个工具控制在同一个session中，
在一个terminal窗口里显示和切换，
比较简洁。&lt;/p&gt;
&lt;p&gt;然而开机启动时还是需要敲入下面的命令：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;Ctrl-Alt-t&amp;gt;
screen
bash some_path/startproxy
&amp;lt;Ctrl-a&amp;gt; c
bash some_path/goagent
&amp;lt;Ctrl-a&amp;gt; c
bash some_path/dnsproxy
&lt;/pre&gt;
&lt;p&gt;非常繁琐。&lt;/p&gt;
&lt;p&gt;于是考虑编写脚本让screen自动化创建新的window跑上述的三个命令，
并让screen自动detach退到后台，
需要时再手动开启新的Terminal调用screen重新attach查看工作情况。&lt;/p&gt;
&lt;div class="section" id="screen"&gt;
&lt;h2&gt;screen的终端参数命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;detach模式启动并执行新命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动新的session并为其命名，
同时在这个session里执行命令并detach：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
screen -S &amp;lt;session-name&amp;gt; -d -m &amp;lt;command&amp;gt;
&lt;/pre&gt;
&lt;p&gt;session-name是给定的名字，
command是实际执行的命令，
可以带参数。&lt;/p&gt;
&lt;p&gt;另外默认情况下执行命令会进入到screen的session里，
使用-d -m指定detach模式，
这样相当于后台执行，
不进入该命令的window。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在现有的session中新建window跑命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;screen用session-name识别不同的session。
开新的window跑新命令用这个：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
screen -S &amp;lt;session-name&amp;gt; -X screen &amp;lt;command&amp;gt;
&lt;/pre&gt;
&lt;p&gt;前提条件是这个session存在，
否则会提示“No screen session found.”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;终端命令使用screen的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于执行的命令是直接通过命令参数给到screen的session中的，
因此命令执行完成后session会被自动终止。&lt;/p&gt;
&lt;p&gt;例如下面的随意一个命令：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
screen -S test_screen ls
screen -S test_screen -d -m ls
&lt;/pre&gt;
&lt;p&gt;都会直接返回，
因为命令执行完成后screen自动退出了。&lt;/p&gt;
&lt;p&gt;但是下面几个就不会：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
screen -S test_screen_top top
screen -S test_screen_top -d -m top
&lt;/pre&gt;
&lt;p&gt;因为top一直在执行，
第一行命令会自动进入screen的session并且显示top的输出，
第二行命令需要自己调用screen重新attach到对应的session并获得top的输出，
否则一直在后台运行。&lt;/p&gt;
&lt;p&gt;此外需要注意的是命令执行的成功与否一般看不出来-_-|||
因此博主的办法是检查当前的session是否存在，
并且进去看看是不是在执行目标命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重新attach现有的session&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
session -r &amp;lt;session-name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;不多说。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;screen的控制命令&lt;/h2&gt;
&lt;p&gt;突然发现居然没写过这货的介绍，
这里顺路补充一下。&lt;/p&gt;
&lt;p&gt;开启screen新session的最直接命令就是在终端里：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
screen
&lt;/pre&gt;
&lt;p&gt;这样便在新的session中创建了一个window并等待输入命令。&lt;/p&gt;
&lt;p&gt;查看当前的所有session可以敲：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
screen -ls
&lt;/pre&gt;
&lt;p&gt;在screen中，
默认的控制指令是&amp;lt;Ctrl-a&amp;gt;，
常见的命令有如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
新的window：&amp;lt;Ctrl-a&amp;gt;, c
切换到下一个window：&amp;lt;Ctrl-a&amp;gt;, n
切换到上一个window：&amp;lt;Ctrl-a&amp;gt;, p
detach当前session：&amp;lt;Ctrl-a&amp;gt;, d
&lt;/pre&gt;
&lt;p&gt;screen的退出与终端的退出相同，
当所有的windows都被&amp;lt;Ctrl-d&amp;gt;或者exit后整个screen的session就自动终止。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;screen自动化脚本的完整实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于工作路径问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;博主的shell脚本都放在相同的目录里，
因此在一个脚本中调用其他脚本可直接使用&amp;quot;./some_sh.sh&amp;quot;。
然而问题在于工作路径是根据脚本被调用时终端所在的工作路径来的，
因此在home目录下调用则工作路径就变成&amp;quot;/home&amp;quot;，
自然就没办法执行不在目录下的其他脚本了。&lt;/p&gt;
&lt;p&gt;博主原来的解决办法是在脚本的第一行给个cd，
并且用绝对路径写死，
确保切换到正确的工作路径，
问题在于写死的东西总是不够灵活。&lt;/p&gt;
&lt;p&gt;后来发现可以通过dirname解决问题。
dirname可以从带路径的文件名称中截取出路径来，
例如&amp;quot;/home/laoyi/abc/test.sh&amp;quot;可以截取到&amp;quot;/home/laoyi/abc&amp;quot;，
因此在脚本中这么来一下就可以获得相对当前的目标路径，
再执行一次cd就可以确保在任何路径下调用脚本都能够正常运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;DIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;dirname &lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="nv"&gt;$DIR&lt;/span&gt;
&lt;span class="nv"&gt;session_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;network_tool
screen -S &lt;span class="nv"&gt;$session_name&lt;/span&gt; -d -m bash ./goagent
screen -S &lt;span class="nv"&gt;$session_name&lt;/span&gt; -X screen bash ./dnsproxy
screen -S &lt;span class="nv"&gt;$session_name&lt;/span&gt; -X screen bash ./startproxy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置session的名称为network_tool方便随时reattach查看状态。&lt;/p&gt;
&lt;p&gt;至此，
启动所有工具只需要一个命令：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bash some_path/start_network_tools.sh
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="lxde"&gt;
&lt;h2&gt;LXDE中开机启动项的添加&lt;/h2&gt;
&lt;p&gt;既然从七八个命令降到一个命令，
何不再进一步直接让脚本开启运行呢，
更加省事。&lt;/p&gt;
&lt;p&gt;于是博主查了一下Arch Linux的文档，
发现可以通过添加命令到下面这个文件中直接添加启动项：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
~/.config/lxsession/LXDE/autostart
&lt;/pre&gt;
&lt;p&gt;如果文件不存在直接新建即可。&lt;/p&gt;
&lt;p&gt;于是将上面的命令扔到autostart文件中，
从此开机自动运行所有工具，
上网只需直接开启firefox。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="Bash"></category></entry><entry><title>Arch Linux学习：Arch Linux启动二三事</title><link href="/Arch005.html" rel="alternate"></link><updated>2014-01-20T11:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-20:Arch005.html</id><summary type="html">&lt;p&gt;本系列博文记录学习Arch Linux这个Linux发行版过程中的总结与收获。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="arch"&gt;
&lt;h2&gt;关于Arch的启动流程&lt;/h2&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;基本流程&lt;/h3&gt;
&lt;p&gt;在BIOS主板下，
Arch Linux的启动流程大致有以下几个步骤：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1. 电源接通，系统开机自检
2. BIOS搜索并根据配置调用对应的硬件进行启动
3. 假设装有Arch的硬盘作为优先启动项，则硬盘的MBR被BIOS读取执行
4. MBR接管，读取数据启动bootloader
5. bootloader启动，初始化数据及配置文件等
6. bootloader启动完毕，载入linux kernel及initramfs，并启动kernel
7. kernel启动，解包initramfs，初始化早期的用户空间，启动/init作为首个进程
8. initramfs作为临时的根文件系统，载入所有运行系统必须的模块，用于启动引导系统的设备
9. 相应的模块启动成功，系统继续引导，真实的根目录挂载并替换初始化根文件系统
10./sbin/init替换/init继续引导过程，systemd启动
11.进程调用getty，提供登录窗口等待用户登入
12.getty获取用户输入，与/etc/passwd匹配，并根据配置初始化用户的环境
&lt;/pre&gt;
&lt;p&gt;至此，基本的系统启动流程就完成了，
后续的用户登入后的图形界面启动等过程则因人而异。&lt;/p&gt;
&lt;p&gt;UEFI模式的主板由于没有接触，
在此暂时不讨论。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mbr"&gt;
&lt;h3&gt;MBR&lt;/h3&gt;
&lt;p&gt;存储设备的头440字节，
储存特殊的启动数据，
以及磁盘的相关信息。&lt;/p&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Master_Boot_Record"&gt;https://wiki.archlinux.org/index.php/Master_Boot_Record&lt;/a&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="bootloader"&gt;
&lt;h3&gt;Bootloader&lt;/h3&gt;
&lt;p&gt;根据IBM相关资料的说法，
Bootloader紧跟在MBR之后，
负责启动kernel并传入相应参数，
以及initramfs的载入。&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Boot_Loaders"&gt;https://wiki.archlinux.org/index.php/Boot_Loaders&lt;/a&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="kernel"&gt;
&lt;h3&gt;Kernel&lt;/h3&gt;
&lt;p&gt;操作系统的核心，
沟通应用程序与系统硬件之间的桥梁，
管理系统资源。&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Kernel"&gt;https://wiki.archlinux.org/index.php/Kernel&lt;/a&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="initramfs"&gt;
&lt;h3&gt;Initramfs&lt;/h3&gt;
&lt;p&gt;支撑系统启动的一个重要的环节。
这货据称用于创建一个早期的用户空间，
启动所有必备的模块，
包括但不限于IDE设备，SCSI设备，SATA设备及USB设备等。
当系统被储存在USB等设备上时，
支撑USB设备的模块必须首先被启动，否则系统没有办法从USB上读取接下去的数据。
因此initramfs专门用于处理这种模块的启动。&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/initramfs"&gt;https://wiki.archlinux.org/index.php/initramfs&lt;/a&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="getty"&gt;
&lt;h3&gt;Getty&lt;/h3&gt;
&lt;p&gt;不是一个东西，
是一类终端管理器的总称。
提供了系统登录、用户验证等功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Getty"&gt;https://wiki.archlinux.org/index.php/Getty&lt;/a&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="systemd"&gt;
&lt;h3&gt;systemd&lt;/h3&gt;
&lt;p&gt;Linux系统的系统和服务管理器。
提供一个抢占式的系统并行处理能力，
同时还提供了多种系统快照和恢复的功能。&lt;/p&gt;
&lt;p&gt;systemd的终端控制命令为&lt;/p&gt;
&lt;blockquote&gt;
systemctl&lt;/blockquote&gt;
&lt;p&gt;可以通过man详细了解一下。&lt;/p&gt;
&lt;p&gt;感觉这货什么东西都能够管理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/systemd"&gt;https://wiki.archlinux.org/index.php/systemd&lt;/a&gt;&lt;/blockquote&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;概念一多有些都搞得有点乱。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;图形化启动界面&lt;/h2&gt;
&lt;p&gt;不知道grub的bootloader默认的启动界面是怎么样的，
之前用ubuntu的时候还是挺好看的，
背景是一个地球以及debian的logo。&lt;/p&gt;
&lt;p&gt;syslinux就有点难看了，
蓝色的底色，白色的字，
没有背景图。&lt;/p&gt;
&lt;p&gt;好在syslinux提供了启动界面的图形化显示，
就像live cd默认的那种style。
更换起来也非常简单。&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/syslinux"&gt;https://wiki.archlinux.org/index.php/syslinux&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;教程中有详细的说明，
基本的处理是改配置文件。&lt;/p&gt;
&lt;p&gt;首先需要一份vesamenu.c32，
在我的系统里目录下本来就已经有了，
因此这一步被我跳过。&lt;/p&gt;
&lt;p&gt;然后把配置文件/boot/syslinux/syslinux.cfg内容更换一下，
主要的点在于UI那个部分，
从原来的menu.c32更换成刚才复制的那个vesamenu.c32，
还有设置了一些菜单的位置啊色彩啦之类的。&lt;/p&gt;
&lt;p&gt;接着要弄一张背景图片。
博主太懒了，感觉live cd的那个图片还挺好看，
就直接从live cd里相同文件夹里面的splash.png复制了过来，
然后在配置文件里有一项设置背景图片：&lt;/p&gt;
&lt;blockquote&gt;
MENU BACKGROUND splash.png&lt;/blockquote&gt;
&lt;p&gt;即可。&lt;/p&gt;
&lt;p&gt;最后博主还小小改动了一把，
将menu的title换成自己的名字，
效果不错。
^_^&lt;/p&gt;
&lt;p&gt;建议在更改的时候备份一下原文件，
在出问题进不了系统的时候可以用live cd引导，
去相同目录里面把新的配置文件干掉，
恢复原来的配置文件，
即可解决问题。&lt;/p&gt;
&lt;p&gt;修改bootloader的启动界面，完毕。&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;一些感受&lt;/h2&gt;
&lt;p&gt;这么些天的学习逐渐了解了一些unix哲学，
像上述的配置文件风格，
在自行geek系统的时候提供了非常大的方便。&lt;/p&gt;
&lt;p&gt;而简单、单一并且强大的程序设计风格也非常令人赏心悦目。
接口定义良好、内部严谨的程序为多个程序的协作提供了非常方便的平台，
很多时候我们需要的只是一个管道，
便可完成非常复杂的处理。&lt;/p&gt;
&lt;p&gt;系统部件之间的耦合度降低也很有利于整体结构的清晰，
通过强大的管理器（pacman之类），
新增或者删除某些部件不会对其他无关的组件造成影响。
同时这也让删除操作更加彻底，
就像pacman，除了一些配置文件，
系统能够自动分析并删除所有属于被删除组件的文件。
不像某Xindows，
藏污纳垢，程序之间一大堆错综复杂的关系，
还需要专门的工具进行垃圾清理...
最经典的实例来自同学安装SQL server的时候，
由于Visual Studio的SQL server lite部件没有彻底删除导致新的SQL server无法安装，
处理了好几天才搞定。&lt;/p&gt;
&lt;p&gt;在此之上的arch linux不仅传承了unix哲学的精华，
还将simple的style更加发扬光大。&lt;/p&gt;
&lt;p&gt;基础性简单性的安装给用户提供了非常透明的基本系统，
让用户随时掌握当前的状态并随时能够作出调整；
同时，最大限度的自由选择和自由配置让用户能够随时geek属于自己的最适合的系统，
相比某dows的系统结构，虽然给一般用户非常简单的上手，
但在图形界面没有相关功能或者崩溃了的情况下用户许多时候却束手无策。
所以博主经常被拉去帮忙重装系统...&lt;/p&gt;
&lt;/div&gt;
</summary><category term="Arch"></category></entry><entry><title>Arch Linux学习：Repository与Pacman小记</title><link href="/Arch004.html" rel="alternate"></link><updated>2014-01-17T19:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-17:Arch004.html</id><summary type="html">&lt;p&gt;本系列博文记录学习Arch Linux这个Linux发行版过程中的总结与收获。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="arch-linux"&gt;
&lt;h2&gt;Arch Linux 仓库&lt;/h2&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3&gt;仓库的分类&lt;/h3&gt;
&lt;p&gt;Arch Linux的官方仓库包含如下的五个类别：
Core, Extra, Community，Multilib，Testing&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;仓库简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;core&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;core仓库包含了所有系统必备的包。
例如bootloader，kernel，building packages等。
貌似安装系统的时候敲pacstrap的时候就是通过连接镜像站点并获取core内容完成本地系统安装的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;extra&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;extra仓库包含了所有不是系统必须的包。
类似于Firefox啦X11图形界面啦mplayer啦都在里面。
另外Python之类的也属于extra的内容。
据说这个仓库比较庞大，毕竟许多常用的东西都在里面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;community&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个仓库存放了所有社区中可信用户提交并获得投票通过的包。&lt;/p&gt;
&lt;p&gt;社区中用户可以提交自己的包到AUR中，
所谓的AUR全称是Arch User Repository，
用户可以在AUR中下载并编译别人写的包，
再让pacman安装到自己的系统中。&lt;/p&gt;
&lt;p&gt;经过大家的使用鉴定，
可以通过投票表决某些好用的包进入community仓库。&lt;/p&gt;
&lt;p&gt;AUR和community的关系就显而易见了，
pacman只能直接获取community的内容，
AUR的东西需要自行下载安装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;multilib&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有点神奇的仓库，
存放了许多32位的库文件，
针对64位系统提供32位软件的构建和执行的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;testing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顾名思义，
正在测试的包可以在这个仓库里找到。
一个包被弄进testing的原因一种是可能会破坏当前的系统，因此需要测试；
或者是正等待其他依赖的包重新构建。&lt;/p&gt;
&lt;p&gt;testing中的包最终会被弄进core或者extra里面去。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;博主查看了本地的pacman设置文件，
默认情况下pacman只启用core,extra和community三个仓库。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pacman"&gt;
&lt;h2&gt;Pacman的简介、配置与基本命令&lt;/h2&gt;
&lt;p&gt;Pacman是Arch Linux的包管理器，
类似于Ubuntu的apt，
提供了自动化的依赖关系管理维持、
自动化的仓库更新和本地系统更新，
以及本地的包管理。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;相关文件&lt;/h3&gt;
&lt;pre class="literal-block"&gt;
pacman的日志记录：/var/log/pacman.log
pacman的配置文件：/etc/pacman/pacman.conf
pacman的镜像列表：/etc/pacman.d/mirrorlist
pacman的本地cache文件夹：/var/cache/pacman/pkg/
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;配置&lt;/h3&gt;
&lt;p&gt;pacman的配置文件在这里: /etc/pacman.conf&lt;/p&gt;
&lt;p&gt;可以查man pacman.conf看到所有配置的字段。&lt;/p&gt;
&lt;p&gt;在Repository块中去掉对应的项前面的注释便可以启用相应的仓库，
包括testing、multilib等。
注意使用testing的时候需要把它放置在仓库列表的最上一项，
因为testing中的包与其他仓库的包可能重名。&lt;/p&gt;
&lt;p&gt;没事还是别拿testing开玩笑的好。&lt;/p&gt;
&lt;p&gt;另外在IgnorePkg后面的包将会被pacman无视，不会自动更新。
在IgnoreGroup后面的组也不会被更新。&lt;/p&gt;
&lt;p&gt;不推荐使用Ignore，
因为连带的更新会让依赖的包版本变化，
某些单独的包不被更新很容易出现依赖问题。&lt;/p&gt;
&lt;p&gt;这种事情在博主安装virtualbox的时候就出现过，
由于kernel版本过旧导致依赖kernel的virtualbox出现问题无法启动。&lt;/p&gt;
&lt;p&gt;都是些不太常用的配置。&lt;/p&gt;
&lt;p&gt;下面这货才是主要的，
镜像列表的编辑：&lt;/p&gt;
&lt;p&gt;从这里搞一份镜像列表：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://www.archlinux.org/mirrorlist/"&gt;https://www.archlinux.org/mirrorlist/&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;贴到本地的mirrorlist文件中：&lt;/p&gt;
&lt;blockquote&gt;
/etc/pacman.d/mirrorlist&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;常用命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;刷新包列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如前面的博文说过的，
更新过mirrorlist的话要用这货更新包的列表：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Syy&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装特定的若干个包敲这个命令：&lt;/p&gt;
&lt;blockquote&gt;
pacman -S package1 package2 ......&lt;/blockquote&gt;
&lt;p&gt;也可以安装一个组，例如gnome：&lt;/p&gt;
&lt;blockquote&gt;
pacman -S gnome&lt;/blockquote&gt;
&lt;p&gt;这种情况下pacman会出一个列表询问需要安装包组里面的哪些特定的包，或者是全部。&lt;/p&gt;
&lt;p&gt;有时候在多个仓库中存在相同的包，那么需要在名称前加入仓库名称指定：&lt;/p&gt;
&lt;blockquote&gt;
pacman -S repo_name/package_name&lt;/blockquote&gt;
&lt;p&gt;跟apt一样，
不用处理依赖关系，
pacman会自动连带安装所有必须的依赖。&lt;/p&gt;
&lt;p&gt;另外博主在使用的时候发现，
在安装好某些包后可选的依赖也会被列举出来，
提醒用户可安装某些额外的功能。&lt;/p&gt;
&lt;p&gt;在某个包已被安装的情况下，
pacman会尝试重新安装，
不管当前的版本是否有差别。
这种特性可以通过加入 --needed 选项去除。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;特殊的安装&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
pacman -U path/to/file.pkg.tar.xz&lt;/blockquote&gt;
&lt;p&gt;上面这货可以从本地安装不在镜像服务器中的包。
用于从AUR中下载的包需要这种安装方式。
此外上面的路径可以换成url。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除某个包（仅删除该包，没有处理依赖）：&lt;/p&gt;
&lt;blockquote&gt;
pacman -R package&lt;/blockquote&gt;
&lt;p&gt;删除某个包并把它的依赖（如果没有被其他包依赖的话）连带删除：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Rs package&lt;/blockquote&gt;
&lt;p&gt;删除某个包、其依赖的包、以及依赖它的包： (-_-)&lt;/p&gt;
&lt;blockquote&gt;
pacman -Rsc package&lt;/blockquote&gt;
&lt;p&gt;删除某个包并忽略所有依赖它的包：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Rdd package&lt;/blockquote&gt;
&lt;p&gt;/*这里有一个补充说明，
默认情况下pacman是不允许删除被依赖的包的，
博主在之前删除ibus的时候，
ibus-googlepinyin还存在依赖关系，
导致pacman 报错退出。*/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;升级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全自动升级&lt;/p&gt;
&lt;blockquote&gt;
pacman -Syu&lt;/blockquote&gt;
&lt;p&gt;官方的说法是升级的时候需要小心，
需要确定pacman列出的升级列表，
还要确定是否需要手动处理一些配置文件的替换工作。&lt;/p&gt;
&lt;p&gt;可供参考的有arch官方的RSS订阅，announce的邮件列表以及twitter账户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库有两款，
其一是本地local数据库，
保存的是当前系统安装的包;
其二是远端镜像sync仓库中当前的列表，
保存所有最新的数据。&lt;/p&gt;
&lt;p&gt;可用-Q参数查询local库，
用-S参数查询sync数据库。&lt;/p&gt;
&lt;p&gt;搜索包含某个关键词的包：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Ss string1 string2 string3 ...&lt;/blockquote&gt;
&lt;p&gt;搜索本地库就把S改成Q：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Qs string1 ...&lt;/blockquote&gt;
&lt;p&gt;加入i参数可查看某个包的详细信息(注意上面是字段搜索，这个是包名称)：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Si package&lt;/blockquote&gt;
&lt;p&gt;同样，查看本地：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Qi package&lt;/blockquote&gt;
&lt;p&gt;两个i的话可以查看连带的备份文件及编辑状态(啥...)&lt;/p&gt;
&lt;blockquote&gt;
pacman -Qii package&lt;/blockquote&gt;
&lt;p&gt;列出所有该包安装的文件(拿kernel试了一发，效果不错)：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Ql package&lt;/blockquote&gt;
&lt;p&gt;反向查询某个文件属于的包：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Qo path/to/file&lt;/blockquote&gt;
&lt;p&gt;列出所有不再被依赖的包(一直在纠结能不能把搜出来的东西给删掉...)：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Qdt&lt;/blockquote&gt;
&lt;p&gt;还能树状列出某个包的依赖：&lt;/p&gt;
&lt;blockquote&gt;
pactree package&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;缓存的相关内容&lt;/h3&gt;
&lt;p&gt;pacman的安装机制是这样的，
首先从mirrorlist中查询url，
从url中搜索是否存在目标包，
如果没有的话则返回404，
继续搜索下一个url，
找到的话则下载对应的包。&lt;/p&gt;
&lt;p&gt;下载完成放在cache目录里，
也就是/var/cache/pacman/pkg&lt;/p&gt;
&lt;p&gt;最后从本地的cache中安装对应的包到系统里面，
完成。&lt;/p&gt;
&lt;p&gt;升级也是一样的处理，
下载并存放到cache里，
再安装新版本的软件。&lt;/p&gt;
&lt;p&gt;于是ls一发cache目录可以找到所有之前安装过的包文件。&lt;/p&gt;
&lt;p&gt;根据Arch官方的说法，保留旧版本的包的好处在于如果新版本运行出现问题，
可以使用手头的旧版本降级处理解决。&lt;/p&gt;
&lt;p&gt;但感觉咱这种循规蹈矩整天看着wiki安装extra仓库东西的人，
应该不会手气太差，
加上那么一堆安装包感觉很占地方。&lt;/p&gt;
&lt;p&gt;于是可以使用下面的命令清理一下：&lt;/p&gt;
&lt;p&gt;清除所有旧版本的包：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Sc&lt;/blockquote&gt;
&lt;p&gt;Arch的推荐是确定当前版本没有问题的情况下才执行这种操作，
否则出现问题比较麻烦。&lt;/p&gt;
&lt;p&gt;清除缓存：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Scc&lt;/blockquote&gt;
&lt;p&gt;整个缓存清空。Arch官方不推荐这种操作。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;pacman的基本用法就这么多了，
查询其他额外信息，找man是不错的选择，另外也可以去这里：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Pacman"&gt;https://wiki.archlinux.org/index.php/Pacman&lt;/a&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Arch"></category></entry><entry><title>Arch Linux学习：安装篇(三)</title><link href="/Arch003.html" rel="alternate"></link><updated>2014-01-16T19:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-16:Arch003.html</id><summary type="html">&lt;p&gt;本系列博文记录学习Arch Linux这个Linux发行版过程中的总结与收获。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="virtualbox"&gt;
&lt;h2&gt;关于VirtualBox的安装&lt;/h2&gt;
&lt;p&gt;看了教程感觉很难搞，光是篇幅就吓死人。&lt;/p&gt;
&lt;p&gt;昨天看清楚才发现原来是自己搞错了，
在Arch Linux里装VirtualBox是不难的，
大概也就两页的篇幅。&lt;/p&gt;
&lt;p&gt;首先需要以下的包，
用pacman装就可以了。&lt;/p&gt;
&lt;blockquote&gt;
virtualbox&lt;/blockquote&gt;
&lt;p&gt;pacman会自动连带安装host-modules。&lt;/p&gt;
&lt;p&gt;别想不开用终端去操作，
再装个Qt吧，
装完就有熟悉的界面了，
如果以前用过virtualbox的话。&lt;/p&gt;
&lt;blockquote&gt;
qt4&lt;/blockquote&gt;
&lt;p&gt;我用的是默认的kernel，
所以接下去就不用怎么配置了，
如果想每次手动启动virtualbox的话，
在启动之前敲这个就可以了：&lt;/p&gt;
&lt;blockquote&gt;
modprobe vboxdrv&lt;/blockquote&gt;
&lt;p&gt;像我这种整天挂个win7当代理服务器的，
把这个模块扔到启动配置文件里去比较方便。&lt;/p&gt;
&lt;p&gt;方法是在/etc/modules-load.d/里建立一个新的*.conf文件，
起个好听的名字，比如virtualbox.conf，
内容就加入这句即可：&lt;/p&gt;
&lt;blockquote&gt;
vboxdrv&lt;/blockquote&gt;
&lt;p&gt;这样就能够在每次启动的时候自动启动这个模块。&lt;/p&gt;
&lt;p&gt;据称这个模块作为虚拟机的基础模块，
必须在启动虚拟机前正确启动。
自己测试的时候如果没有启动这货直接启动虚拟机，
系统会报错并退出。&lt;/p&gt;
&lt;p&gt;然后，
桌面环境里开启virtualbox，
该干嘛干嘛。&lt;/p&gt;
&lt;div class="section" id="troubleshooting"&gt;
&lt;h3&gt;troubleshooting&lt;/h3&gt;
&lt;p&gt;虽然教程说的非常简单，
博主在安装的时候还是出了很大的问题。&lt;/p&gt;
&lt;p&gt;在安装完启动vboxdrv的时候系统报错：&lt;/p&gt;
&lt;blockquote&gt;
modprobe: ERROR: could not insert 'vboxdrv': Exec format error.&lt;/blockquote&gt;
&lt;p&gt;搜了半天的google没有找到好的解决方案。
一般遇到这种问题是自制的kernel或者非标准kernel在复杂模式下安装之后可能会出现的。&lt;/p&gt;
&lt;p&gt;可能的情况是virtualbox的编译针对的不是当前的kernel，
导致模块执行失败。&lt;/p&gt;
&lt;p&gt;我就搞不懂了为何官方默认的kernel照着教程搞也会出这种问题。&lt;/p&gt;
&lt;p&gt;有一种解决方案是安装dkms(virtualbox-host-dkms)然后设置vboxhost指向当前版本的kernel。&lt;/p&gt;
&lt;p&gt;照着别人的建议安装了dkms，
指向的时候还是报错，
说没有kernel的header，
貌似是头文件一类的东西。&lt;/p&gt;
&lt;p&gt;遂放弃。&lt;/p&gt;
&lt;p&gt;另有国外牛人的建议是重新编译virtualbox。
先下载virtualbox的源文件，
再下载kernel的header，
最后用dkms编译...&lt;/p&gt;
&lt;p&gt;当时一看头就大了。&lt;/p&gt;
&lt;p&gt;后来结合多方的解决方案，
查了一下发现自己的kernel是3.12.6-1，
跟最新版本3.12.7-1有点差距。
另外官方的virtualbox看样子是针对最新版本的kernel编译，
于是升级了内核：&lt;/p&gt;
&lt;blockquote&gt;
pacman -S linux&lt;/blockquote&gt;
&lt;p&gt;再重新安装了一下virtualbox，
果然问题就解决了。&lt;/p&gt;
&lt;p&gt;经验在于：
官方的仓库一般都是针对最新版本的kernel编译，
所以对于有些对kernel版本非常敏感的程序来说，
出问题的时候要关注一下自己的kernel是否兼容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nat"&gt;
&lt;h3&gt;NAT网络地址转换与端口转发&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NAT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学过计算机网络的兄弟对这货应该都不陌生。
virtualbox自带模块能够将host系统作为类似路由的东西，
将guest系统的包全部通过host系统转发出去。&lt;/p&gt;
&lt;p&gt;NAT的优势在于简单、方便、安全。
virtualbox默认启动了NAT，不用配置便可以使用。
在博主亲测下不论是arch linux的guest系统还是windows的guest系统都能够直接识别并自动连接网络。&lt;/p&gt;
&lt;p&gt;其次，host系统作为路由器存在，
对外界隐藏了本地guest系统的存在，
这也就大大降低了guest系统被入侵的几率。&lt;/p&gt;
&lt;p&gt;另外，多个guest虚拟主机之间也杜绝了数据泄漏的问题，因为guest系统之间也是无法互相识别的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;端口转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NAT的一个缺陷在于，
外界无法检测到guest系统的存在，
因此如果有某些服务需要监听端口获取外界的连接（SSL、FTP、http服务器等），
默认情况下NAT无法处理。&lt;/p&gt;
&lt;p&gt;因此就有了端口转发的机制解决这个问题。&lt;/p&gt;
&lt;p&gt;端口转发将host系统的某个端口（或者某个IP的端口）转发到guest系统的某个端口上，
例如将host的80转发到guest的80，
那么在guest上监听80端口的http服务器就可以对外服务了。
而从外部看来就是连接了host的服务器。&lt;/p&gt;
&lt;p&gt;virtualbox里配置端口转发非常方便，
在network里选advance添加端口转发规则即可。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;Arch Linux的基本安装和配置就都搞定了，
下一回准备聊一下systemd或者pacman之类的知识和应用。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Arch"></category></entry><entry><title>Arch Linux学习：安装篇(二)</title><link href="/Arch002.html" rel="alternate"></link><updated>2014-01-14T19:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-14:Arch002.html</id><summary type="html">&lt;p&gt;本系列博文记录学习Arch Linux这个Linux发行版过程中的总结与收获。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;当你看到这篇博文的时候，
老逸的新系统已安装完毕，
弹冠相庆！^_^&lt;/p&gt;
&lt;p&gt;替换掉原来恶心的win7+Ubuntu双系统，
现在直接将整个硬盘重新分区并安装Arch Linux.&lt;/p&gt;
&lt;p&gt;分区如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 298.1G  0 disk
├─sda1   8:1    0   500M  0 part /boot
├─sda2   8:2    0    50G  0 part /
├─sda3   8:3    0     2G  0 part [SWAP]
├─sda4   8:4    0   100G  0 part /home
└─sda5   8:5    0 145.6G  0 part /data
&lt;/pre&gt;
&lt;p&gt;除了swap外所有分区均使用ext4。
根据Arch官方说法，留多25%的空间能够消除碎片，
考虑到300G硬盘的实际使用率，因此确定了上面的分区方案。&lt;/p&gt;
&lt;p&gt;boot分区给了夸张的500M，因为1G以下的空间对现在的硬盘来说都不够算。
root分区因为要装一些软件什么的，考虑到之前的Ubuntu只有10G也没用尽，因此给了50G以防以后拓展。
home分区用来存自己的数据，文档啦源码啦，还有我这网站的content也在里面，乱七八糟的都放，给了个100G。
剩下的统统交给data，计划用来放些电影啦音乐啥子的，这种搞法其实是Arch的文档中介绍的。&lt;/p&gt;
&lt;p&gt;基本配置如下，列表以供参考：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
partition table: GPT
bootloader: syslinux
linux kernal: 3.12.6-1-ARCH (tobias&amp;#64;T-POWA-LX)
Desktop Environment: Lightweight X11 Desktop Environment(LXDE)
&lt;/pre&gt;
&lt;p&gt;由于确定不再使用windows，所以完全没有考虑双系统的兼容性问题，带来的好处就是可以直接使用新款分区表GPT，
相比老旧的MBR确实优势多多。
bootloader也相应选择了看起来更加牛逼一些的syslinux，安装过程也非常顺利方便。（当然，相比windows的无人值守性质的安装还是多少有一些事情要做的。不过windows嘛，就不说什么了...）
内核就没有自己geek一番了，毕竟是生手第一次安装，主要考虑系统的稳定性和便捷性，直接pacstrap搞定。&lt;/p&gt;
&lt;p&gt;应用软件方面还是以轻量级为主。&lt;/p&gt;
&lt;p&gt;桌面环境直接排除了GNOME和KDE，GNOME虽然效果非常炫，但用起来机器居然有时会卡，而且GNOME本身也过于庞大。
KDE的话，看到Arch官网的介绍和GNOME同属重量级的环境，就一起排除了。
在xfce和LXDE之间纠结了很久，因为这俩货主打轻量级，而且是官方支持的版本。
之前用的是xfce，考虑到尝鲜的因素、浏览器的因素（LXDE推荐网页浏览器是Firefox），以及其他心理因素，最终确定使用LXDE作为桌面环境。&lt;/p&gt;
&lt;p&gt;输入法本来安装了ibus和googlepinyin，用了两次感觉比较不爽，默认的界面非常难看，而且启动也有点慢（居然要我开启完桌面环境好一会之后才自己慢吞吞出现在菜单栏里）。
所以果断换了fcitx。刚换上去就知道找对东西了，不仅开启的速度非常快，不用怎么配置，而且默认的黑色界面也和我的桌面主题很搭。再装上google拼音，好用的很。&lt;/p&gt;
&lt;p&gt;浏览器就Firefox无疑了，autoProxy用起来忒爽。这里插句题外话，前天给家里的winXP(老古董，想换个Lubuntu，但不是我在用，麻烦。=_=)装Firefox，居然下错Firefox搞到一个中国版，各种插件各种弹窗，各种恶心...提醒大家装Firefox去官网选择中文原版，别去中国官网下，当然故意找插件的除外。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;桌面环境的安装&lt;/h2&gt;
&lt;p&gt;安装桌面环境首先要安装xorg-server，直接pacman就行。&lt;/p&gt;
&lt;p&gt;接着是mesa，据说是用来处理3D显示的。&lt;/p&gt;
&lt;p&gt;然后要搞定显卡的驱动。&lt;/p&gt;
&lt;p&gt;从这里：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Xorg#Driver_installation"&gt;https://wiki.archlinux.org/index.php/Xorg#Driver_installation&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;可以找到自己显卡对应的驱动，pacman安装即可。&lt;/p&gt;
&lt;p&gt;现在便可以通过启动X来测试了，直接命令：startx
如果能出几个框框鼠标能动，说明安装正确，不行的话就找troubleshooting咯。&lt;/p&gt;
&lt;p&gt;安装好X便可以选择一个桌面环境自己安装了，所谓的根据喜好选择。 ^_^&lt;/p&gt;
&lt;p&gt;最后是一些配置什么的，就不赘述了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;杂七杂八的经验&lt;/h2&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;关于虚拟机&lt;/h3&gt;
&lt;p&gt;虚拟机的安装很容易出现问题，
上回博主在virtualbox里安装的时候曾经在bootloader里卡很久，
所有的配置都没有问题，但敲回车选择进入Arch，屏幕闪了一下又跳回bootloader主界面。&lt;/p&gt;
&lt;p&gt;查文档说如果敲了回车什么事情都没有发生，说明是配置错误引导系统失败。&lt;/p&gt;
&lt;p&gt;但是多敲几次回车它却偶尔会进系统，并且系统完全正常...&lt;/p&gt;
&lt;p&gt;此外，显示器的识别也出现过问题。
在virtualbox里startx失败，报错为：没有找到显示器&lt;/p&gt;
&lt;p&gt;所幸这些问题在自己的真机里都没有出现，一切顺利。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mirrorlist"&gt;
&lt;h3&gt;关于mirrorlist&lt;/h3&gt;
&lt;p&gt;有了虚拟机的麻烦经历，
实体安装的时候我把mirrorlist内容全部换成国内几个速度很快的服务器，
效果非常好，
速度一般都有几百K到几个M。&lt;/p&gt;
&lt;p&gt;不过遇到了另一个问题，
不知为何国内的服务器某些软件找不到。
具体的忘记了，但有不少的软件在国内的服务器返回了404，导致pacman报错。&lt;/p&gt;
&lt;p&gt;于是不得不再次更改mirrorlist加几个山姆大叔家的服务器。&lt;/p&gt;
&lt;p&gt;最终的最佳实践是：
首先放几个离自己的地域最近的服务器（相同国家一般就可以了）。
然后在文件的末尾放几个山姆大叔的主力服务器，找那些score高的，用于国内服务器找不到资源时的备用。
要注意把远程的服务器放在文件末尾，因为pacman是按顺序搜索的。&lt;/p&gt;
&lt;p&gt;另外，千万要记得的是，每次更新mirrorlist要敲这个：&lt;/p&gt;
&lt;blockquote&gt;
pacman -Syy&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;关于时间&lt;/h3&gt;
&lt;p&gt;时间的同步可以按教程搞：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Network_Time_Protocol"&gt;https://wiki.archlinux.org/index.php/Network_Time_Protocol&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;官方的说法是，没有启动deamon的情况下敲这个：&lt;/p&gt;
&lt;blockquote&gt;
ntpd -q&lt;/blockquote&gt;
&lt;p&gt;不过我倒是没搞定 -_-&lt;/p&gt;
&lt;p&gt;貌似服务器连接有问题，
而且更恶心的是同步失败是没有任何出错提示的。&lt;/p&gt;
&lt;p&gt;最后在google上找到另一款方案：&lt;/p&gt;
&lt;blockquote&gt;
ntpdate 0.us.pool.ntp.org&lt;/blockquote&gt;
&lt;p&gt;记得写入硬件时钟：&lt;/p&gt;
&lt;blockquote&gt;
hwclock -w&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;一些好用的命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;lsblk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这货最近敲了很多次，不带参数则显示所有存储设备的分区情况，也可以加入参数限定显示的设备。&lt;/p&gt;
&lt;p&gt;博文最前面的分区信息显示就是用lsblk打出来的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ip link&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;搞网络也花了一些时间。&lt;/p&gt;
&lt;p&gt;这货显示当前所有网络设备的详细信息。&lt;/p&gt;
&lt;p&gt;启动某个设备敲：&lt;/p&gt;
&lt;blockquote&gt;
ip link set [device] up&lt;/blockquote&gt;
&lt;p&gt;其中device是设备的名称，在ip link输出中的第一个便是。
一般来说e开头的是有线网卡，wl开头的是无线网卡。lo据称是本地的回路，不是真实网卡。&lt;/p&gt;
&lt;p&gt;然后自己被坑的地方是这里：&lt;/p&gt;
&lt;p&gt;教程说首先使用ip link set让对应的设备state为up，然后便可以连接。
但要注意的是这种说法对应的是有线网卡的情况。
如果是无线网卡，直接set是没法让它从down变成up的，
只有成功创建连接后自己才会更改状态。&lt;/p&gt;
&lt;p&gt;于是我花了好久时间一直在研究为何没法让它up，
而google到的结果看样子没有人遇到这种奇葩情况。
直到第二天睡醒想想算了不管它直接用wifi-menu连接看看，
一试才发现这货根本就没有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wifi-menu 和 dhcpcd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个方便的东西，wifi-menu加上无线网卡的设备名作为参数，
自动搜索并列表显示所有找到的网络，
还能输入密码自动创建连接。&lt;/p&gt;
&lt;p&gt;而dhcpcd可以用在有线网卡里，
默认状态下网卡是down的，用上面的ip link让它up，
然后直接敲dhcpcd，
全自动连接并从路由的dhcp服务里获取并设置网络。
一般根据自己的网络环境选用上面俩命令的一个，成功执行便能ping www.google.com了。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;下一次将尝试安装virtualbox，据说很难搞...&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Arch"></category></entry><entry><title>Arch Linux学习：安装篇(一)</title><link href="/Arch001.html" rel="alternate"></link><updated>2014-01-08T19:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-08:Arch001.html</id><summary type="html">&lt;p&gt;本系列博文记录学习Arch Linux这个Linux发行版过程中的总结与收获。&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;关于Arch Linux&lt;/h2&gt;
&lt;p&gt;Arch Linux是一个现在较为流行的Linux发行版，
支持32/64位处理器,
以Rolling Releases方式发布新版本。&lt;/p&gt;
&lt;p&gt;官方站点：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.archlinux.org"&gt;https://www.archlinux.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Arch Linux的哲学是简洁、保证代码的正确性、用户为中心、开放性及自由性。
因此据称Arch Linux的一个非常重要的特点是轻量级，
让用户自行选择所需的组件构建属于自己的系统，
当然这都以系统的开放性作为前提，
Arch Linux提供了非常大的自由度和开放度供用户完全控制自己的系统。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/The_Arch_Way"&gt;https://wiki.archlinux.org/index.php/The_Arch_Way&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Arch Linux支持syslinux或GRUB两种bootloader，
包管理器为Pacman(package manager)，
使用systemd作为系统的服务管理器(这货还没弄清楚)&lt;/p&gt;
&lt;p&gt;在下列资源的帮助下我顺利完成了系统的安装:&lt;/p&gt;
&lt;p&gt;一个是Arch官方的Beginners' Guide:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Beginners%27_Guide"&gt;https://wiki.archlinux.org/index.php/Beginners%27_Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个是某牛人写的手把手教程(虽然略微显老，不过参考价值很大)：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://wideaperture.net/blog/?p=3851"&gt;http://wideaperture.net/blog/?p=3851&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人推荐先用牛人的教程研究一遍整体流程，
再以官方教程为主着手操作，
因为有些命令的参数可能由于版本更新发生变化，
以官方版本为参考可有效避免产生问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;环境&lt;/h2&gt;
&lt;p&gt;由于初次尝试安装Arch Linux，
我选择在虚拟机里练手，
熟悉了流程之后再将自己的系统完整转移到Arch上。&lt;/p&gt;
&lt;p&gt;宿主操作系统为Ubuntu 12.04 x64 桌面版&lt;/p&gt;
&lt;p&gt;VirtualBox 的版本为4.1.12&lt;/p&gt;
&lt;p&gt;选择的Arch Linux安装镜像为2012.12.01版本。&lt;/p&gt;
&lt;p&gt;没有使用最新版是因为在VirtualBox里最新版本启动失败，
感觉VB(VirtualBox)对较新版本的系统支持都不是特别好，
之前也有试过在Windows下用VB安装Ubuntu 13.04，
结果以失败告终，
后来换Ubuntu 12.04就解决了问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;基本步骤总结&lt;/h2&gt;
&lt;p&gt;假设是全新安装，
不考虑windows系统的双引导问题，
Arch Linux系统的主要安装步骤有如下几步：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;硬盘分区&lt;/li&gt;
&lt;li&gt;分区格式化&lt;/li&gt;
&lt;li&gt;基本系统安装&lt;/li&gt;
&lt;li&gt;fstab的生成和系统的配置&lt;/li&gt;
&lt;li&gt;bootloader的安装和配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;在安装过程中需要保证网络连接，
以让系统自动从镜像网站中获取所需的资源。
另一种搞法是将Arch的核心库下载储存到本地的存储介质上并设定系统从中读取资源。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;详细记录&lt;/h2&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3&gt;0)准备阶段&lt;/h3&gt;
&lt;p&gt;首先需要有一份完整的光盘镜像，
建议在使用镜像之前检查一下md5和sha1的散列值，
防止由于数据丢失导致的问题。&lt;/p&gt;
&lt;p&gt;Ubuntu下可以使用md5sum和sha1sum命令计算文件的散列值&lt;/p&gt;
&lt;p&gt;关于硬盘大小有几种说法，
官方说的貌似只要500M的空间便可完成基本安装,
而大牛的教程直接搞了40G的空间。
反正现在空间都是白菜价，
搞大一点也好。&lt;/p&gt;
&lt;p&gt;内存方面能有个512M就能跑得很欢了。&lt;/p&gt;
&lt;p&gt;此外大牛的教程里还开启了VirtualBox的显卡3D加速，
调大了显存容量。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3&gt;1)光盘引导和硬盘分区&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;引导系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arch Linux的光盘镜像中包含了32位和64位两个版本的系统。
如果是正式安装的话，
由于现在主流的硬件都支持64位，
因此推荐选用较新的64位系统。&lt;/p&gt;
&lt;p&gt;而如果是虚拟机则推荐使用较好的兼容性和低硬件需求的32位系统。&lt;/p&gt;
&lt;p&gt;正常的话，
光盘镜像会被引导，
选择所需的系统版本,
系统自动载入并自动登录为root。&lt;/p&gt;
&lt;p&gt;在一大堆输出之后应该出现一个终端窗口等待命令：&lt;/p&gt;
&lt;blockquote&gt;
root&amp;#64;archiso ~ #&lt;/blockquote&gt;
&lt;p&gt;这说明光盘的系统进入成功了。&lt;/p&gt;
&lt;p&gt;如果过程中死了，可参考Arch官方的troubleshooting:&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Troubleshooting_boot_problems"&gt;https://wiki.archlinux.org/index.php/Beginners%27_Guide#Troubleshooting_boot_problems&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;另外，
如果上述方案无法解决问题，
并且是在虚拟机中安装的话，
可以观察一下自己所用的系统版本，
选择较老的版本以换取较好的兼容性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方的说法是选择自己的语言版本并去除对应的注释，
然后启用相应的语言。&lt;/p&gt;
&lt;p&gt;个人推荐保持English较好，
我尝试过选择中文，
可能是字体没有设置正确，
导致后面的操作中文字符都无法显示。&lt;/p&gt;
&lt;p&gt;另外一个好处是English的错误直接贴进Google里搜可以得到很多的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arch Linux会自动配置网络连接，
通过Ping一下Google查看网络是否正常。
如果有问题的话再尝试自行设置网络：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Establish_an_internet_connection"&gt;https://wiki.archlinux.org/index.php/Beginners%27_Guide#Establish_an_internet_connection&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;硬盘分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先需要选择分区表。&lt;/p&gt;
&lt;p&gt;一种是常见的MBR主引导记录，
windows便是使用该分区表。
糟糕的是MBR比较旧，
最多只能有三个主分区和一个拓展分区，
在拓展分区上继续划分逻辑分区。
分区的大小也有限，
最多只支持2T的空间，
超过部分无法识别。
而且需要设定某个分区为活动分区才可引导系统。
不过某些老的BIOS只支持MBR，
另外如果有windows的话只能使用MBR。&lt;/p&gt;
&lt;p&gt;不考虑老BIOS兼容性和windows的兼容性的话，
应该尽量使用更新的GPT分区表，
不仅分区数量提高到128个，
空间限制也加大到2Z。
没有活动分区限制。
某些新款的UEFI类型的主板只支持GPT分区表。&lt;/p&gt;
&lt;p&gt;关于分区表的选择可参考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/GUID_Partition_Table"&gt;https://wiki.archlinux.org/index.php/GUID_Partition_Table&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Master_Boot_Record"&gt;https://wiki.archlinux.org/index.php/Master_Boot_Record&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对不同的分区表Arch Linux提供了不同的分区工具，
我选择的是GPT分区表，
下面使用cgdisk进行分区操作。&lt;/p&gt;
&lt;p&gt;如果有多个硬盘的话要区分好需要在哪个硬盘上操作，
避免因为选错硬盘导致的数据丢失。&lt;/p&gt;
&lt;p&gt;假设在sda硬盘上进行分区：&lt;/p&gt;
&lt;blockquote&gt;
cgdisk /dev/sda&lt;/blockquote&gt;
&lt;p&gt;进入cgdisk后有界面，
选择新建啦分配大小啦，
就不废话了。&lt;/p&gt;
&lt;p&gt;注意的是swap分区的代号是8200，
新建分区的默认代号是8300，
因此在创建swap分区时要注意不能选择默认设置。&lt;/p&gt;
&lt;p&gt;另外一点是要在底端的空白空间上新建分区，
最上方的空白空间貌似是给分区表用的，
需要留空。&lt;/p&gt;
&lt;p&gt;至于分区大小，
可参考这里：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Partitioning#How_big_should_my_partitions_be.3F"&gt;https://wiki.archlinux.org/index.php/Partitioning#How_big_should_my_partitions_be.3F&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;分区完成后要写入更改。&lt;/p&gt;
&lt;p&gt;最后退出cgdisk回到终端。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;2) 分区格式化&lt;/h3&gt;
&lt;p&gt;在硬盘分区完成后，
每个分区被赋予一个数值表示该分区的编号。&lt;/p&gt;
&lt;p&gt;因此假设sda硬盘分区完成，
那么/dev/中会出现若干个sda开头的设备。&lt;/p&gt;
&lt;p&gt;sda1表示sda硬盘的第一个分区，
sda2表示sda硬盘的第二个分区。&lt;/p&gt;
&lt;p&gt;查看某个硬盘的情况可以用这个：&lt;/p&gt;
&lt;blockquote&gt;
lsblk /dev/sda&lt;/blockquote&gt;
&lt;p&gt;结果以树状结构呈现硬盘的分区情况。&lt;/p&gt;
&lt;p&gt;格式化是非常方便的，
安装Arch Linux要求分区格式为ext4。
用下面的命令格式化sda1:&lt;/p&gt;
&lt;blockquote&gt;
mkfs.ext4 /dev/sda1&lt;/blockquote&gt;
&lt;p&gt;记得对其他分区也要做一遍。&lt;/p&gt;
&lt;p&gt;对于swap分区，使用下面的命令(假设是第三个分区)：&lt;/p&gt;
&lt;blockquote&gt;
mkswap /dev/sda3&lt;/blockquote&gt;
&lt;p&gt;还要启用这个swap分区：&lt;/p&gt;
&lt;blockquote&gt;
swapon /dev/sda3&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;3) 基本系统安装&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;挂载分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分区完成之后就要在新划分的分区里面安装系统了，
因此首先要做的是把分区挂载到当前运行的光盘系统中。&lt;/p&gt;
&lt;p&gt;挂载的顺序非常重要，
我们直到Unix类型系统都是以根目录作为整个系统文件树的起点，
因此首先把作为root的分区挂载到当前系统的/mnt里去。&lt;/p&gt;
&lt;p&gt;假设作为root的分区是sda1:&lt;/p&gt;
&lt;blockquote&gt;
mount /dev/sda1 /mnt&lt;/blockquote&gt;
&lt;p&gt;接着在挂载后的root目录(也就是当前的/mnt)下新建相应的文件夹挂载其余的分区。
假设需要挂载boot分区(sda2)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mkdir /mnt/boot&lt;/p&gt;
&lt;p&gt;mount /dev/sda2 /mnt/boot&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;依次搞定剩余的分区就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜像站点选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个一定要搞一下，
本人第一次安装时因为没有更改镜像站点导致下载速度超慢，
本以为pacman应该有什么内置的功能自动选择最优的站点下载，
后来感觉好像没有这个功能，
它只是扫了一遍配置文件从头到尾一个个尝试连接并下载需要的资源而已。&lt;/p&gt;
&lt;p&gt;首先要在以下的地址选择并生成在自己的地区最合适的镜像站点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://www.archlinux.org/mirrorlist/"&gt;https://www.archlinux.org/mirrorlist/&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;然后编辑文件/etc/pacman.d/mirrorlist，
教程里用的是nano，我不太习惯，
换成vi也是可以的(没有vim，将就着用吧)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到了正题反而简单得很，
如果网络配置正常、
镜像站点正常、
硬盘分区和挂载正确的话，
敲下面这个命令就ok了：&lt;/p&gt;
&lt;blockquote&gt;
pacstrap -i /mnt base&lt;/blockquote&gt;
&lt;p&gt;去掉-i参数的话会默认安装所有基础的组件。
其实就算加了-i，看到白花花的列表里那么多东西，
也没什么欲望一个个去考虑要不要了。
既然都是基础的组件，
就全部安装好了。
反正相比windows，
再多也不多~&lt;/p&gt;
&lt;p&gt;大牛的教程说到这一步可以去喝杯咖啡，
也可以坐在屏幕前面欣赏（如果觉得进度的变化能让自己感觉很high的话）&lt;/p&gt;
&lt;p&gt;反正就是等......&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于系统安装的补充说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然上面的一个命令就可以搞定基础系统的安装，
但仍然有很多不确定因素会导致安装的中断。
就像我第一次安装的时候等到五点要去吃饭了它资源还没有下载完毕，
于是一狠心就把它Ctrl+C了...-_-|||&lt;/p&gt;
&lt;p&gt;令人欣喜的是等到我吃完饭回来，
重新光盘引导并挂载分区(文件夹什么的都在了，挂载分区开启swap就可以了)，
并且还改了mirrorlist，
重新pacstrap，
发现它依然能够继续之前的下载，
最终正常完成系统安装。&lt;/p&gt;
&lt;p&gt;观察它的安装过程，应该是这样的，
首先是将所有需要的文件下载到本地，
然后一次性执行所有程序的安装。
由于我在下载的中途中断了，
下一次进入pacman会自动扫描现有的文件，
继续所有未完成的下载，
最终才开始安装。&lt;/p&gt;
&lt;p&gt;至于安装的过程中断会怎么样呢？&lt;/p&gt;
&lt;p&gt;感觉有点恐怖...哪个兄弟试过的烦请告知...&lt;/p&gt;
&lt;p&gt;此外，
官方文档的Note有如下的说明：&lt;/p&gt;
&lt;blockquote&gt;
Whenever in the future you change your list of mirrors,
always remember to force pacman to refresh all package lists with 'pacman -Syy'.
This is considered to be good practice and will avoid possible headaches.
See Mirrors for more information.&lt;/blockquote&gt;
&lt;p&gt;所以，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;修改了mirrorlist记得要 pacman -Syy&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fstab"&gt;
&lt;h3&gt;4) fstab的生成和系统的配置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;fstab文件生成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一步生成一份fstab文件，
这个文件的作用在于配置当前系统的分区状况，
使得每次启动系统的时候自动挂载分区。
相当于静态的文件系统信息。&lt;/p&gt;
&lt;blockquote&gt;
genfstab -U -p /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/blockquote&gt;
&lt;p&gt;完成后要检查文件内容是否正确，
直接cat或者more或者less或者vi、nano都可以。
类似的内容在大牛的文章中有截图。&lt;/p&gt;
&lt;p&gt;完成了前面的步骤，
Arch Linux的基础系统就算是安装到本地的磁盘上了。
接下来要做一些简单的配置工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;切换系统并配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先是要切换到新安装的系统里。
没有错，系统已经可以运行，
现在要切换到新的系统里去。&lt;/p&gt;
&lt;blockquote&gt;
arch-chroot /mnt /bin/bash&lt;/blockquote&gt;
&lt;p&gt;这句切换到新系统里并让默认的shell为Bash。
去掉后面的第二个参数则会使用sh的shell。&lt;/p&gt;
&lt;p&gt;执行成功的话现在就在新系统里运行了，
会发现终端的提示符中主机已经不再是archiso，
而是当前的系统。&lt;/p&gt;
&lt;p&gt;区域、语言、主机名称什么的就不多说了，
照着教程搞即可。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bootloader"&gt;
&lt;h3&gt;5) bootloader的安装和配置&lt;/h3&gt;
&lt;p&gt;最后一步是安装bootloader。
bootloader用于在系统启动时引导进入系统。&lt;/p&gt;
&lt;p&gt;设想系统硬件启动完成，
BIOS(UEFI)按引导顺序将系统的引导权传递到硬盘中，
那么硬盘怎么能够知道去哪里找对应的系统启动呢？
靠的就是bootloader。
bootloader储存在磁盘的开始部分，
当系统启动时，自动到磁盘的开始位置搜索bootloader，
并由其完成剩余的启动工作。&lt;/p&gt;
&lt;p&gt;大牛的文章里有一个非常精妙的类比，
这货就像高度近视的人每天醒来第一件事是伸手去拿放在固定位置的眼镜，
没有眼镜的话人将没有办法做任何事情（无法进入系统），
而眼镜总是放在固定的位置（床头啊什么的，就像磁盘的开始处一样），
因此不用花功夫思考去哪里找眼睛（BIOS也一样，只会在磁盘的开始处搜索），
直接伸手去拿即可。&lt;/p&gt;
&lt;p&gt;一解释就显得罗嗦...&lt;/p&gt;
&lt;p&gt;但其实安装bootloader是非常便捷的，
照着教程做就可以了。
一个注意的地方是要确定自己的主板是BIOS还是UEFI，
此外安装完成后（需要的话）记得要把引导的位置修改为root所在的分区代号。&lt;/p&gt;
&lt;p&gt;完成后退出当前系统（回到光盘系统），
umount所有挂载的分区，
reboot并让硬盘引导，
正常的话会出现bootloader的界面，
选择合适的选项进入即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;关于bootloader的补充说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装错误或者配置错误什么的都会导致bootloader引导失败，
可参考官方的troubleshooting。&lt;/p&gt;
&lt;p&gt;弄死了是没有关系的，
重新光盘引导，
挂载分区和swap分区（别忘了swap分区），
哪里错了就从哪里重新开始。
肯定有一天能够安装正确配置成功并进入系统的。(^_^)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一旦配置正确，系统引导成功，
一堆输出过后会出现一个终端并等待命令，
没有错&lt;/p&gt;
&lt;p&gt;这说明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arch Linux 安装完成了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;啥？没有图形界面？&lt;/p&gt;
&lt;p&gt;自己装X-server啊，
喜欢哪个窗口管理器（Gnome,xfce，KDE什么的）自己再弄上去。
( 参考：&lt;a class="reference external" href="https://wiki.archlinux.org/index.php/Beginners%27_Guide#Graphical_User_Interface"&gt;https://wiki.archlinux.org/index.php/Beginners%27_Guide#Graphical_User_Interface&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;我觉得光是这一点就充分体现了Arch Linux的简介性和高度的可定制性了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Arch"></category></entry><entry><title>Bash笔记(四)</title><link href="/Bash004.html" rel="alternate"></link><updated>2014-01-05T22:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-05:Bash004.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;本系列博文记录学习Shell终端Bash过程中的收获，主要为常用命令一览表及相关功能的记录。&lt;/strong&gt;&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;用户管理&lt;/h2&gt;
&lt;p&gt;Unix的用户列表在/etc/passwd中，
该文件为每个用户保存了一行信息，
包括用户名、用户id、组id、用户描述、用户的home目录及默认的shell信息&lt;/p&gt;
&lt;p&gt;用户密码加密后保存在/etc/shadow文件中，
包含用户名、用户密码、最小密码修改间隔时间、最大密码修改间隔时间、密码无效前提醒时间等。
时间的单位是天。&lt;/p&gt;
&lt;p&gt;用户的密码管理默认设置在/etc/login.defs中。
设置了包含上述几个时间在内的多个参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;识别用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;whoami&lt;/p&gt;
&lt;blockquote&gt;
查看当前用户名&lt;/blockquote&gt;
&lt;p&gt;who&lt;/p&gt;
&lt;blockquote&gt;
列表显示当前所有登录用户相关信息&lt;/blockquote&gt;
&lt;p&gt;who am i&lt;/p&gt;
&lt;blockquote&gt;
这货是空格分开的，相当于who，只显示当前用户&lt;/blockquote&gt;
&lt;p&gt;w&lt;/p&gt;
&lt;blockquote&gt;
这个能显示当前所有用户正在执行的工作&lt;/blockquote&gt;
&lt;p&gt;id&lt;/p&gt;
&lt;blockquote&gt;
显示当前用户的用户id，组id等&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;用户管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;useradd&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建一个新用户scutlaoyi，设置home目录及用户描述&lt;/p&gt;
&lt;p&gt;useradd -m -d /home/scutlaoyi -c &amp;quot;new user&amp;quot; scutlaoyi&lt;/p&gt;
&lt;p&gt;系统默认给新用户一个独立的用户id和组id.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;userdel&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;删除用户，-r设置连带删除对应的home目录&lt;/p&gt;
&lt;p&gt;userdel -r [username]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;usermod&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编辑用户信息，例如，修改用户描述&lt;/p&gt;
&lt;p&gt;usermod -c &amp;quot;just a user&amp;quot; [username]&lt;/p&gt;
&lt;p&gt;锁定某个用户的密码，使其不能正常登录&lt;/p&gt;
&lt;p&gt;usermod -L [username]&lt;/p&gt;
&lt;p&gt;解锁&lt;/p&gt;
&lt;p&gt;usermod -U [username]&lt;/p&gt;
&lt;p&gt;设置默认登录的shell&lt;/p&gt;
&lt;p&gt;usermod -s /bin/bash [username]&lt;/p&gt;
&lt;p&gt;设定用户归属的组(注意这个操作会清除用户原有的组归属数据)&lt;/p&gt;
&lt;p&gt;usermod -G [groupname] [username]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;passwd&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不带参数输入可修改当前用户密码&lt;/p&gt;
&lt;p&gt;passwd&lt;/p&gt;
&lt;p&gt;对某个用户设置密码&lt;/p&gt;
&lt;p&gt;passwd [username]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;用户切换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;su&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快速切换到某个用户,包括root也行，如果你有密码&lt;/p&gt;
&lt;p&gt;su [username]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sudo&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo命令可以让当前用户以root权限执行程序。&lt;/p&gt;
&lt;p&gt;sudo [command]&lt;/p&gt;
&lt;p&gt;sudo命令可以在不交出root密码的前提下给某些用户root权限管理系统。&lt;/p&gt;
&lt;p&gt;sudo命令成功的前提是当前用户在/etc/sudoers文件中存在对应的权限。
没有权限而执行sudo的话，在我的Ubuntu里会显示错误信息，
并威胁道:&amp;quot;此事件将被报告。&amp;quot; -_-\&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;visudo&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudoers文件的专用编辑器，可防止多种安全问题。&lt;/p&gt;
&lt;p&gt;关于该命令的具体信息可查man。&lt;/p&gt;
&lt;p&gt;不推荐直接编辑/etc/sudoers文件。
（虽然上次糊里糊涂用vim编辑了一次，还好没死。-_-\）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;组管理&lt;/h2&gt;
&lt;p&gt;用户组的信息保存在/etc/group文件中。
其格式为：组名:组密码(可能为空):组id:组内成员列表&lt;/p&gt;
&lt;p&gt;groupadd&lt;/p&gt;
&lt;blockquote&gt;
添加一个组
groupadd [groupname]&lt;/blockquote&gt;
&lt;p&gt;添加用户到某个组中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用usermod，-a为保持原有组信息并追加新组&lt;/p&gt;
&lt;p&gt;usermod -a -G [groupname] [username]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;groupmod&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编辑组名称&lt;/p&gt;
&lt;p&gt;groupmod -n [new_groupname] [groupname]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;groupdel&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;删除组&lt;/p&gt;
&lt;p&gt;groupdel [groupname]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;groups&lt;/p&gt;
&lt;blockquote&gt;
查看当前用户所属的组信息&lt;/blockquote&gt;
&lt;p&gt;gpasswd&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;赋予某些用户管理组的权限&lt;/p&gt;
&lt;p&gt;设定某个组的管理员&lt;/p&gt;
&lt;p&gt;gpasswd -A [user1],[user2],[...] [groupname]&lt;/p&gt;
&lt;p&gt;使某个用户加入组&lt;/p&gt;
&lt;p&gt;gpasswd -a [username] [groupname]&lt;/p&gt;
&lt;p&gt;从组中清除某个用户&lt;/p&gt;
&lt;p&gt;gpasswd -d [username] [groupname]&lt;/p&gt;
&lt;p&gt;设定某个组的成员&lt;/p&gt;
&lt;p&gt;gpasswd -M [user1],[user2],[...]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;文件权限&lt;/h2&gt;
&lt;p&gt;Unix类系统的文件权限分为三种：
文件所有者权限、文件所属组权限、其他人权限。
文件的权限有三款：读(r)、写(w)、执行(x)。&lt;/p&gt;
&lt;p&gt;当使用ls -l命令时，可以看到列表中每个文件的最左方即文件的权限设置&lt;/p&gt;
&lt;p&gt;第一个字符为文件类型，文件类型有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-:普通文件&lt;/p&gt;
&lt;p&gt;d:目录&lt;/p&gt;
&lt;p&gt;l:符号链接文件&lt;/p&gt;
&lt;p&gt;p:命名管道&lt;/p&gt;
&lt;p&gt;b:块设备&lt;/p&gt;
&lt;p&gt;c:字符设备&lt;/p&gt;
&lt;p&gt;s:socket&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着每三个字符依次指定了对应的权限：所有者、组、其他人。
r、w、x分别说明拥有该项权限，横杆-说明无此权限。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;drwxr-xr-x 2 laoyi laoyi    4096 12月 23 20:28 desktop&lt;/p&gt;
&lt;p&gt;该文件是一个目录，
所有者拥有读写执行权限，
组用户拥有读和执行权限，
而其他人也拥有读和执行权限&lt;/p&gt;
&lt;p&gt;后面的依次是所有者、所有组，大小，时间和名称等信息。&lt;/p&gt;
&lt;p&gt;chgrp&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改一个文件的组&lt;/p&gt;
&lt;p&gt;chgrp [groupname] [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;chown&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改一个文件的所有者&lt;/p&gt;
&lt;p&gt;chown [username] [filename]&lt;/p&gt;
&lt;p&gt;同时修改所有者和组&lt;/p&gt;
&lt;p&gt;chown [username]:[groupname] [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;chmod&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;代号方式管理权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;u为所有者，g为组用户，o为其他人，a对上述三者同时操作&lt;/p&gt;
&lt;p&gt;+为增加权限， 相反， -为去除权限&lt;/p&gt;
&lt;p&gt;r读，w写，x执行&lt;/p&gt;
&lt;p&gt;权限配置可以多个组合&lt;/p&gt;
&lt;p&gt;chmod u+w [filename]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字方式管理权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读的数值为4， 写的数值为2， 执行的数值为1&lt;/p&gt;
&lt;p&gt;对应权限的数字求和得到最终的权限数值&lt;/p&gt;
&lt;p&gt;因此下述例子分配所有者读写执行权限，组用户读和执行权限，其他人读取的权限&lt;/p&gt;
&lt;p&gt;chmod 754 [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;简单的Bash命令就到此为止了，
后面的一些比较复杂我就不记了，
像ACL之类的，
现在学一下过几天也会忘，
以后用到我再搞上来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;明天开始搞Arch Linux!&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</summary><category term="Bash"></category></entry><entry><title>Bash笔记(三)</title><link href="/Bash003.html" rel="alternate"></link><updated>2014-01-04T22:00:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-04:Bash003.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;本系列博文记录学习Shell终端Bash过程中的收获，主要为常用命令一览表及相关功能的记录。&lt;/strong&gt;&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;常用过滤器&lt;/h2&gt;
&lt;p&gt;cat&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就是把输入流或文件内容输出出来&lt;/p&gt;
&lt;p&gt;cat [filename]&lt;/p&gt;
&lt;p&gt;文件太长就可以用less分页显示&lt;/p&gt;
&lt;p&gt;cat [filename] | less&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tee&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;管道默认把输出作为下一级的输入，
某些情况下需要显示保存中间结果（管道很长之类的），
可以使用tee&lt;/p&gt;
&lt;p&gt;tee类似cat将输入作为标准输出，同时输出到文件&lt;/p&gt;
&lt;p&gt;tac [filename] | tee [tempfilename] | tac | [......]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;grep&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unix中的一个非常重要的过滤器。&lt;/p&gt;
&lt;p&gt;在输入流中搜索并输出符合对应条件的行,
下面这货过滤出所有带'str'的行&lt;/p&gt;
&lt;p&gt;cat [filename] | grep 'str'&lt;/p&gt;
&lt;p&gt;设置过滤对大小写不敏感&lt;/p&gt;
&lt;p&gt;grep -i [str]&lt;/p&gt;
&lt;p&gt;反向过滤，找出所有不包含str的行&lt;/p&gt;
&lt;p&gt;grep -v [str]&lt;/p&gt;
&lt;p&gt;设置连带输出目标行后的4行（数字可变）&lt;/p&gt;
&lt;p&gt;grep -A4 ......&lt;/p&gt;
&lt;p&gt;设置连带输出目标行前的3行&lt;/p&gt;
&lt;p&gt;grep -B3 ......&lt;/p&gt;
&lt;p&gt;设置连带输出目标行前后的2行&lt;/p&gt;
&lt;p&gt;grep -C2 ......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;cut&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;截取并输出若干列的文本&lt;/p&gt;
&lt;p&gt;设置分割符为':', 输出第一列和第三列的文本&lt;/p&gt;
&lt;p&gt;cut -d: -f1,3 [filename]&lt;/p&gt;
&lt;p&gt;设置分割符为空格时要用引号包括起来&lt;/p&gt;
&lt;p&gt;cut -d&amp;quot; &amp;quot; -f1,2,3,5 [filename]&lt;/p&gt;
&lt;p&gt;还可设置截取字符范围&lt;/p&gt;
&lt;p&gt;截取每行第3到第7个字符&lt;/p&gt;
&lt;p&gt;cut -c3-7 [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tr&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字符转换,
例如将小写a转为大写A&lt;/p&gt;
&lt;p&gt;tr 'a' 'A'&lt;/p&gt;
&lt;p&gt;设定范围转换&lt;/p&gt;
&lt;p&gt;tr 'a-z' 'A-Z' #范围不一样会怎样呢？自己试试吧～&lt;/p&gt;
&lt;p&gt;特殊字符也是可以的，
比如说把换行全部换成空格&lt;/p&gt;
&lt;p&gt;tr '\n' ' '&lt;/p&gt;
&lt;p&gt;还能用于压缩多个空格&lt;/p&gt;
&lt;p&gt;tr -s ' '&lt;/p&gt;
&lt;p&gt;移位什么的很方便&lt;/p&gt;
&lt;p&gt;tr 'a-z' 'o-za-n'&lt;/p&gt;
&lt;p&gt;删除所有a/b/c字符&lt;/p&gt;
&lt;p&gt;tr -d 'abc'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;wc&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不是厕所，是字符计数的缩写&lt;/p&gt;
&lt;p&gt;统计行数、字数及字符数&lt;/p&gt;
&lt;p&gt;wc [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sort&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;排序用的，默认是每行按字典序排
//突然想起当年瞎搞ACM的时候被字典序坑过好多次.-_-&lt;/p&gt;
&lt;p&gt;sort [filename]&lt;/p&gt;
&lt;p&gt;按数字大小排&lt;/p&gt;
&lt;p&gt;sort -n [filename]&lt;/p&gt;
&lt;p&gt;按某一列排(假设第三列)&lt;/p&gt;
&lt;p&gt;sort -k3 [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;uniq&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;去掉相同的行&lt;/p&gt;
&lt;p&gt;uniq [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;comm&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;逐行比较两个文件，
仅第一个有的在第一列，
仅第二个有的在第二列，
相同的在第三列&lt;/p&gt;
&lt;p&gt;comm [file1] [file2]&lt;/p&gt;
&lt;p&gt;可设置只显示某几列&lt;/p&gt;
&lt;p&gt;comm -23 [file1] [file2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;od&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可将文件内容编码成其他进制&lt;/p&gt;
&lt;p&gt;转十六进制并输出,每词一个字节&lt;/p&gt;
&lt;p&gt;od -t x1 [filename]&lt;/p&gt;
&lt;p&gt;十进制输出&lt;/p&gt;
&lt;p&gt;od -b [filename]&lt;/p&gt;
&lt;p&gt;ASCII码输出&lt;/p&gt;
&lt;p&gt;od -c [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sed&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用正则表达式编辑文本。&lt;/p&gt;
&lt;p&gt;这货太牛逼了，两三句话说不完，在这里挂个链接吧。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://coolshell.cn/articles/9104.html"&gt;http://coolshell.cn/articles/9104.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="unix"&gt;
&lt;h2&gt;基本的Unix工具&lt;/h2&gt;
&lt;p&gt;find&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;找东西用的，据说直接暴搜得到结果。
想要高效搜索用下面说的locate&lt;/p&gt;
&lt;p&gt;查找某目录(及其子目录)下的所有文件&lt;/p&gt;
&lt;p&gt;find [location]&lt;/p&gt;
&lt;p&gt;查找某目录其子目录下的某种文件(匹配)&lt;/p&gt;
&lt;p&gt;find [location] -name [option]&lt;/p&gt;
&lt;p&gt;eg. find / -name &amp;quot;*.txt&amp;quot; #找系统中的所有txt文件&lt;/p&gt;
&lt;p&gt;查找某种类型文件,关于type可查man&lt;/p&gt;
&lt;p&gt;find [location] -type [type]&lt;/p&gt;
&lt;p&gt;查找并对目标执行某些命令操作，
-exec 后接操作的命令(下述例子删除了目标文件)&lt;/p&gt;
&lt;p&gt;find ~ -name &amp;quot;*.txt~&amp;quot; -exec rm {} \;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;locate&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用索引搜索文件，
比find效率更高&lt;/p&gt;
&lt;p&gt;更新数据库(在我的Ubuntu里要sudo)&lt;/p&gt;
&lt;p&gt;updatedb&lt;/p&gt;
&lt;p&gt;查找文件&lt;/p&gt;
&lt;p&gt;locate [pattern]&lt;/p&gt;
&lt;p&gt;具体情况可以查man&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;date&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;看时间&lt;/p&gt;
&lt;p&gt;date&lt;/p&gt;
&lt;p&gt;自定义格式(A:星期 d:天 m:月 Y:年)&lt;/p&gt;
&lt;p&gt;date +'%A %d-%m-%Y'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;cal&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;月历&lt;/p&gt;
&lt;p&gt;cal&lt;/p&gt;
&lt;p&gt;显示某年某月的月历(1970年三月)&lt;/p&gt;
&lt;p&gt;cal 3 1970&lt;/p&gt;
&lt;p&gt;或者显示整年的日历&lt;/p&gt;
&lt;p&gt;cal 1989&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sleep&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;休眠嘛(单位：秒)&lt;/p&gt;
&lt;p&gt;sleep 100 #别等它...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;time&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取命令运行的时间&lt;/p&gt;
&lt;p&gt;time echo 'hello,world'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;gzip/gunzip:文件压缩工具&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;压缩目标文件，
默认得到同名的后缀为gz的文件。&lt;/p&gt;
&lt;p&gt;注意：原文件会被替换&lt;/p&gt;
&lt;p&gt;gzip [file]&lt;/p&gt;
&lt;p&gt;将gz文件作为目标文件解压缩&lt;/p&gt;
&lt;p&gt;gunzip [file] 或 gzip -d [file]&lt;/p&gt;
&lt;p&gt;zcat命令可查看压缩包文本内容&lt;/p&gt;
&lt;p&gt;zcat [file]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</summary><category term="Bash"></category></entry><entry><title>Bash笔记(二)</title><link href="/Bash002.html" rel="alternate"></link><updated>2014-01-03T22:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-03:Bash002.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;本系列博文记录学习Shell终端Bash过程中的收获，主要为常用命令一览表及相关功能的记录。&lt;/strong&gt;&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;变量&lt;/h2&gt;
&lt;p&gt;dollar sign&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用美元符标记变量,
变量大小写敏感。
常用的系统变量有：&lt;/p&gt;
&lt;p&gt;$HOSTNAME, $USER, $UID, $HOME&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$PS1&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;变量定义终端的提示符,
可通过设置该变量改变提示符的内容：&lt;/p&gt;
&lt;p&gt;$PS1='\u&amp;#64;\h:\W$'&lt;/p&gt;
&lt;p&gt;显示内容：用户&amp;#64;主机:当前目录$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$PATH&lt;/p&gt;
&lt;blockquote&gt;
设定系统搜索执行命令的路径&lt;/blockquote&gt;
&lt;p&gt;使用自定义变量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直接对变量名赋值即可&lt;/p&gt;
&lt;p&gt;MyVar=123&lt;/p&gt;
&lt;p&gt;使用时加上美元符&lt;/p&gt;
&lt;p&gt;echo $MyVar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用变量时引号的差异&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单说来就是这样：&lt;/p&gt;
&lt;p&gt;echo '$MyVar' // $MyVar&lt;/p&gt;
&lt;p&gt;echo &amp;quot;$MyVar&amp;quot; // 123&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;set&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查看当前所有变量&lt;/p&gt;
&lt;p&gt;set&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;env&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查看当前exported的变量&lt;/p&gt;
&lt;p&gt;env&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;unset&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;取消设置某个变量&lt;/p&gt;
&lt;p&gt;unset [variable]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;export&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对某个变量操作使其在子bash中亦可使用,
该操作引入变量对父bash无效&lt;/p&gt;
&lt;p&gt;export [var_name]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变量使用的另外一种方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有时候直接使用$var会有问题，这种情况下可以这样获取变量&lt;/p&gt;
&lt;p&gt;tree=&amp;quot;A big tree &amp;quot; #注意最后空格&lt;/p&gt;
&lt;p&gt;echo ${tree}on the load. #连接处没有空格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bash的options&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;设置在使用未绑定变量时显示错误&lt;/p&gt;
&lt;p&gt;set -u&lt;/p&gt;
&lt;p&gt;echo $a_variable_not_exist #显示错误信息，而不是显示空&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;恢复显示空内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;set +u&lt;/p&gt;
&lt;p&gt;显示当前bash的所有options&lt;/p&gt;
&lt;p&gt;echo $-&lt;/p&gt;
&lt;p&gt;对于每个option的功能可查看man bash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;嵌套Bash&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;echo $(var=1; echo $var)&lt;/p&gt;
&lt;p&gt;var1在内层的Bash中被声明并显示,
在外层的Bash中没有被绑定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外一种使用方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;echo `var=1; echo $var`&lt;/p&gt;
&lt;p&gt;使用反引号替代美元符和括号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个好用的地方在于，可以临时改变工作目录&lt;/p&gt;
&lt;p&gt;echo `cd /bin/; ls`&lt;/p&gt;
&lt;p&gt;命令执行后当前外层的Bash工作目录没有变化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;历史记录&lt;/h2&gt;
&lt;p&gt;bang bang&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显示并执行最近的一次操作&lt;/p&gt;
&lt;p&gt;！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;![string]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用感叹号后接字符串，Bash自动搜索匹配最后一个符合条件的命令，
显示并执行&lt;/p&gt;
&lt;p&gt;echo Hey&lt;/p&gt;
&lt;p&gt;!ec #echo Hey&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;history&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显示最近的number条命令&lt;/p&gt;
&lt;p&gt;history [number]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;![number]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过history获取命令记录后，使用感叹号加数字，
Bash显示并执行对应索引值的命令&lt;/p&gt;
&lt;p&gt;![number]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ctrl-r&lt;/p&gt;
&lt;blockquote&gt;
最方便的历史命令恢复操作，
按Ctrl-r，逐个输入字符串，Bash自动搜索并显示符合条件的记录。
找到需要的命令按回车即可执行&lt;/blockquote&gt;
&lt;p&gt;历史文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bash记录当前环境的历史命令。
当退出时，
Bash将命令操作存在历史文件中。
一般是在~/.bash_history中。&lt;/p&gt;
&lt;p&gt;显示当前环境历史记录的最大长度&lt;/p&gt;
&lt;p&gt;echo $HISTSIZE&lt;/p&gt;
&lt;p&gt;显示历史记录文件的位置&lt;/p&gt;
&lt;p&gt;echo $HISTFILE&lt;/p&gt;
&lt;p&gt;显示历史记录文件的最大长度&lt;/p&gt;
&lt;p&gt;echo $HISTFILESIZE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;文件匹配&lt;/h2&gt;
&lt;p&gt;asterisk&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;匹配任意长度任意字符&lt;/p&gt;
&lt;p&gt;ls *.txt #显示所有后缀为txt的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;question mark&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;匹配一个任意字符&lt;/p&gt;
&lt;p&gt;ls ?.txt #显示所有名称为一个字符后缀为txt的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;square brackets&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;匹配一个中括号中的字符&lt;/p&gt;
&lt;p&gt;ls [ABC].txt #A.txt/B.txt/C.txt&lt;/p&gt;
&lt;p&gt;也可以设定范围，数字或字符&lt;/p&gt;
&lt;p&gt;ls [0-9a-zA-Z].txt #匹配一个数字或大小写字符&lt;/p&gt;
&lt;p&gt;可以用！表示没有&lt;/p&gt;
&lt;p&gt;ls [!4].txt #去掉4.txt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;echo的一个神奇作用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在空目录下&lt;/p&gt;
&lt;p&gt;echo *&lt;/p&gt;
&lt;p&gt;显示一个菊花&lt;/p&gt;
&lt;p&gt;在有文件的目录下&lt;/p&gt;
&lt;p&gt;echo *&lt;/p&gt;
&lt;p&gt;显示所有文件（不包含隐藏文件）&lt;/p&gt;
&lt;p&gt;在使用时如果要显示*可使用逃逸符或引号将菊花包括起来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;重定向与管道&lt;/h2&gt;
&lt;p&gt;输出重定向&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将标准输出(1)重定向到文件&lt;/p&gt;
&lt;p&gt;[command...] &amp;gt; [filename] #同：[command...] 1&amp;gt; [filename]&lt;/p&gt;
&lt;p&gt;上述操作会覆盖原有文件,
可设置Bash的set -C拒绝写入原有文件。&lt;/p&gt;
&lt;p&gt;标准输出(1)追加至文件末尾&lt;/p&gt;
&lt;p&gt;[command...] &amp;gt;&amp;gt; [filename] # [command...] 1&amp;gt;&amp;gt; [filename]&lt;/p&gt;
&lt;p&gt;标准错误流(2)的重定向&lt;/p&gt;
&lt;p&gt;[command...] 2&amp;gt; [destination]&lt;/p&gt;
&lt;p&gt;标准错误流(2)重定向至标准输出流&lt;/p&gt;
&lt;p&gt;[command...] 2&amp;gt;&amp;amp;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入重定向&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准输入流(0)的重定向&lt;/p&gt;
&lt;p&gt;[command...] &amp;lt; [source] # [command] 0&amp;lt; [source]&lt;/p&gt;
&lt;p&gt;输入流结束符的定义&lt;/p&gt;
&lt;p&gt;[command...] &amp;lt;&amp;lt; [sign]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;p&gt;cat &amp;lt;&amp;lt; Hey #读取输入直到遇到Hey结束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;管道&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;管道将一个命令的标准输出作为下一个命令的标准输入&lt;/p&gt;
&lt;p&gt;例子：显示/etc目录文件的末四个&lt;/p&gt;
&lt;p&gt;ls /etc | tail -4&lt;/p&gt;
&lt;p&gt;管道可嵌套&lt;/p&gt;
&lt;p&gt;ls /etc | tail -4 | tac&lt;/p&gt;
&lt;p&gt;关于管道没多少内容，不过发挥想象力可以利用管道和过滤器创造整个世界。&lt;/p&gt;
&lt;p&gt;下一篇将记录过滤器的若干资料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</summary><category term="Bash"></category></entry><entry><title>Bash笔记(一)</title><link href="/Bash001.html" rel="alternate"></link><updated>2014-01-02T22:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-02:Bash001.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;本系列博文记录学习Shell终端Bash过程中的收获，主要为常用命令一览表及相关功能的记录。&lt;/strong&gt;&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;基础知识&lt;/h2&gt;
&lt;p&gt;以echo为例，bash的基本命令及结构如下：&lt;/p&gt;
&lt;p&gt;显示命令后的所有参数&lt;/p&gt;
&lt;p&gt;echo [option] [arg0] [arg1] [arg2] [...]&lt;/p&gt;
&lt;p&gt;命令、参数之间用空格区分，空格数量差异没有作用,
在单引号或双引号之间的所有字符被当成同一个参数&lt;/p&gt;
&lt;p&gt;echo &amp;quot;Hey, this is a single argument.&amp;quot;&lt;/p&gt;
&lt;p&gt;设定option使echo解析字符操作符&lt;/p&gt;
&lt;p&gt;echo -e &amp;quot;A line with n a newline.&amp;quot;&lt;/p&gt;
&lt;p&gt;命令执行成功返回0，否则返回非0值,
返回值的意义可查命令的man&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;命令的帮助文档&lt;/h2&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令有两种类型，内部和外部命令
显示命令的类型&lt;/p&gt;
&lt;p&gt;type [command]&lt;/p&gt;
&lt;p&gt;某些命令有两种类型，显示所有类型&lt;/p&gt;
&lt;p&gt;type -a [command]&lt;/p&gt;
&lt;p&gt;当执行同名命令时内置命令优先，
执行外部命令必须指定命令路径，如echo:&lt;/p&gt;
&lt;p&gt;/bin/echo Hello&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;man&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查找某个命令的手册页&lt;/p&gt;
&lt;p&gt;man [command]&lt;/p&gt;
&lt;p&gt;查找某个配置文件的手册页&lt;/p&gt;
&lt;p&gt;man [configuration file name]&lt;/p&gt;
&lt;p&gt;模糊搜索:查找带string的命令列表&lt;/p&gt;
&lt;p&gt;man -k [string]&lt;/p&gt;
&lt;p&gt;匹配某个section的命令,关于section的解释在man man中有&lt;/p&gt;
&lt;p&gt;man [section] [command]&lt;/p&gt;
&lt;p&gt;查看当前系统的文件系统结构树&lt;/p&gt;
&lt;p&gt;man hier&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;whatis&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话描述命令&lt;/p&gt;
&lt;p&gt;whatis [command]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;whereis&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查找命令的所在目录列表&lt;/p&gt;
&lt;p&gt;whereis [command]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;which&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;which查找命令的路径并确定命令所在目录&lt;/p&gt;
&lt;p&gt;which [command]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;目录操作&lt;/h2&gt;
&lt;p&gt;pwd&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显示当前所在的工作目录&lt;/p&gt;
&lt;p&gt;pwd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;cd&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进入某目录,可使用相对路径或绝对路径&lt;/p&gt;
&lt;p&gt;cd [location]&lt;/p&gt;
&lt;p&gt;进入home目录&lt;/p&gt;
&lt;p&gt;cd ~&lt;/p&gt;
&lt;p&gt;进入上一次的目录(方便！)&lt;/p&gt;
&lt;p&gt;cd -&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ls&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显示当前文件夹内容&lt;/p&gt;
&lt;p&gt;ls [location]&lt;/p&gt;
&lt;p&gt;显示所有文件（包括隐藏文件）&lt;/p&gt;
&lt;p&gt;ls -a [location]&lt;/p&gt;
&lt;p&gt;显示详细信息&lt;/p&gt;
&lt;p&gt;ls -l [location]&lt;/p&gt;
&lt;p&gt;显示详细信息并令文件大小显示更人性化(-_-||)&lt;/p&gt;
&lt;p&gt;ls -lh [location]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mkdir&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建目录&lt;/p&gt;
&lt;p&gt;mkdir [dir_name]&lt;/p&gt;
&lt;p&gt;一个命令创建多层目录&lt;/p&gt;
&lt;p&gt;mkdir -p [dir_name/dir_name/......]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;rmdir&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当目录为空时删除该目录&lt;/p&gt;
&lt;p&gt;rmdir [dir_name]&lt;/p&gt;
&lt;p&gt;一个命令删除目录树&lt;/p&gt;
&lt;p&gt;rmdir -p [dir_name/dir_name/......]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;文件操作&lt;/h2&gt;
&lt;p&gt;file&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显示文件类型&lt;/p&gt;
&lt;p&gt;file [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;touch&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建一个新文件&lt;/p&gt;
&lt;p&gt;touch [filename]&lt;/p&gt;
&lt;p&gt;创建文件并指定时间&lt;/p&gt;
&lt;p&gt;touch -t [time] [filename] //touch -t 201312291830 test&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;rm&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;删除文件(没了就没了啵...)&lt;/p&gt;
&lt;p&gt;rm [filename]&lt;/p&gt;
&lt;p&gt;删除前确认&lt;/p&gt;
&lt;p&gt;rm -i [filename]&lt;/p&gt;
&lt;p&gt;最牛逼的删除操作,强力递归删除目录及目录中的文件&lt;/p&gt;
&lt;p&gt;rm -rf [dirname]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;cp&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;复制文件,从原文件到目标文件&lt;/p&gt;
&lt;p&gt;cp [source_filename] [destination_filename]&lt;/p&gt;
&lt;p&gt;复制文件夹及其中的文件&lt;/p&gt;
&lt;p&gt;cp -r [source_dir] [destination_dir]&lt;/p&gt;
&lt;p&gt;同时复制多个文件到同一个文件夹(最后一个参数务必为一个文件夹)&lt;/p&gt;
&lt;p&gt;cp [file1] [file2] [......] [destination_dir]&lt;/p&gt;
&lt;p&gt;防止复制时的现有文件覆盖&lt;/p&gt;
&lt;p&gt;cp -i [......]&lt;/p&gt;
&lt;p&gt;复制时保留原文件的权限和时间信息&lt;/p&gt;
&lt;p&gt;cp -p [......]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mv&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;移动文件（或者将文件改名）&lt;/p&gt;
&lt;p&gt;mv [source_filename] [destination_filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;文件内容操作&lt;/h2&gt;
&lt;p&gt;head&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;默认显示文件的前十行&lt;/p&gt;
&lt;p&gt;head [filename]&lt;/p&gt;
&lt;p&gt;可以设定显示的行数&lt;/p&gt;
&lt;p&gt;head -[number] [filename] //head -4 test.txt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tail&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;默认显示文件最后十行&lt;/p&gt;
&lt;p&gt;tail [filename]&lt;/p&gt;
&lt;p&gt;同上，设置显示的行数&lt;/p&gt;
&lt;p&gt;tail -[number] [filename]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;cat&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输出文件内容到标准输出中&lt;/p&gt;
&lt;p&gt;cat [filename]&lt;/p&gt;
&lt;p&gt;可同时输出多个文件&lt;/p&gt;
&lt;p&gt;cat [file1] [file2] [file3] [...]&lt;/p&gt;
&lt;p&gt;不指定文件，则从标准输入中读取数据，直到EOF,
可用这个特性创建新文件（利用输出重定向）&lt;/p&gt;
&lt;p&gt;cat &amp;gt; out.txt&lt;/p&gt;
&lt;p&gt;复制文件&lt;/p&gt;
&lt;p&gt;cat in.txt &amp;gt; out.txt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tac&lt;/p&gt;
&lt;blockquote&gt;
与cat相反的输出&lt;/blockquote&gt;
&lt;p&gt;less/more&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;翻页显示文件内容
//更推荐用less,可以使用类似vim的翻页操作，并且支持搜索&lt;/p&gt;
&lt;p&gt;less [filename]&lt;/p&gt;
&lt;p&gt;可将其他命令的输出管道输入到less中&lt;/p&gt;
&lt;p&gt;ls | less&lt;/p&gt;
&lt;p&gt;//关于管道后面有详细说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;strings&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将某个二进制文件中的可读ASCII字符输出
//有点憋屈的命令...&lt;/p&gt;
&lt;p&gt;strings /bin/ls&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;命令的执行与控制&lt;/h2&gt;
&lt;p&gt;alias&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可为某个常用的命令设置别名，别名与原名等同&lt;/p&gt;
&lt;p&gt;alias dog=cat&lt;/p&gt;
&lt;p&gt;同样，可设定带option甚至arguments的别名，需要用引号包含&lt;/p&gt;
&lt;p&gt;alias la='ls -a'&lt;/p&gt;
&lt;p&gt;显示当前所有别名&lt;/p&gt;
&lt;p&gt;alias&lt;/p&gt;
&lt;p&gt;去除别名&lt;/p&gt;
&lt;p&gt;unalias [command]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;set -x&lt;/p&gt;
&lt;blockquote&gt;
开启命令回显&lt;/blockquote&gt;
&lt;p&gt;set +x&lt;/p&gt;
&lt;blockquote&gt;
关闭命令回显&lt;/blockquote&gt;
&lt;p&gt;semicolon&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令与命令之间用分号分隔&lt;/p&gt;
&lt;p&gt;echo Hello; echo Hey&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ampersand&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单个与符号让当前命令在后台执行&lt;/p&gt;
&lt;p&gt;sleep 20 &amp;amp;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;dollar question&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;钱+问号获取前一个命令的返回值&lt;/p&gt;
&lt;p&gt;echo Hey ; echo $?&lt;/p&gt;
&lt;p&gt;//Hey 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;double ampersand&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;双与符号连接两个命令，第二个命令只在第一个命令执行成功时才执行&lt;/p&gt;
&lt;p&gt;echo first &amp;amp;&amp;amp; echo second&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;double vertical bar&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;双竖直分割符连接两个命令，第二个命令只在第一个命令失败(返回非0值)时执行&lt;/p&gt;
&lt;p&gt;echo first || echo second&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;combination&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;组合使用&amp;amp;&amp;amp;和||可以做逻辑处理&lt;/p&gt;
&lt;p&gt;rm file &amp;amp;&amp;amp; echo ok || echo failed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pound sign&lt;/p&gt;
&lt;blockquote&gt;
注释使用#号&lt;/blockquote&gt;
&lt;p&gt;escape character&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用反斜杠作为逃逸符&lt;/p&gt;
&lt;p&gt;echo hello ; world&lt;/p&gt;
&lt;p&gt;也可使用反斜杠作为隔行命令&lt;/p&gt;
&lt;p&gt;echo hello world&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</summary><category term="Bash"></category></entry></feed>