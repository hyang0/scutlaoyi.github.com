<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>老逸的个人站</title><link href="/" rel="alternate"></link><link href="http://www.scutlaoyi.tk/feeds/cpp.atom.xml" rel="self"></link><id>/</id><updated>2014-03-28T22:30:00+08:00</updated><entry><title>C++学习(七)：线性表及搜索相关</title><link href="/CppLearning007-array.html" rel="alternate"></link><updated>2014-03-28T22:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-03-28:CppLearning007-array.html</id><summary type="html">&lt;p&gt;其实这个系列应该归结为数据结构专题的，
但由于记录的都是简单至极的基础知识，
标榜数据结构吸引眼球有点过于隆重，
于是统统放在C++的内容里。&lt;/p&gt;
&lt;p&gt;就算是C++的编程训练罢了。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;数组与链表的归纳总结&lt;/h2&gt;
&lt;p&gt;这些基础概念应该在开始学习编程的时候就有所涉及了，
这里试着总结一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;朴素意义上，
数组与链表一样都是用来储存若干相同类型元素的数据结构，
其特点就是一个或多个元素以先后顺序保存在内存中。&lt;/p&gt;
&lt;p&gt;根据组织方式上的区别区分数组和链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组织区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组占用了内存中的一段连续的空间，
在这段连续空间上，
通过指定数组的类型确定每一个元素占用的空间大小，
由此将所有元素依次紧密排列存放到对应空间上。&lt;/p&gt;
&lt;p&gt;相对的，
链表不占用连续空间，
通过在每个元素中保存下一个元素所在内存地址，
达到组织的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于每个元素占用空间相同，
加上所有元素在同一片连续空间上，
数组可以通过计算某元素相对头元素在内存中的偏移量，
快速访问某个特定的元素。&lt;/p&gt;
&lt;p&gt;而由于相同的原因，
数组在元素的插入和删除操作上比较麻烦，
不管是插入还是删除，
都需要移动所有后续的节点使其重新紧密排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相对于数组，
由于链表元素是通过指针指向下一个节点，
没有连续空间，
因此插入新节点或删除原有节点在正常情况下只需要操作对应位置的前后元素，
使它们的指针指向正确的位置，
对其他元素没有影响，
因此插入删除操作的效率非常高。&lt;/p&gt;
&lt;p&gt;然而，
在访问某个特定节点时，
以单链表为例，
则必须从头节点开始逐个遍历链上的节点直到达到目标节点，
因此相对数组来说访问的效率较低。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;搜索的相关知识&lt;/h2&gt;
&lt;p&gt;最简单的暴力搜索莫过于直接遍历每个元素查找目标元素是否存在。
时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;根据内存组织形式的不同，数组与链表有不同的高速搜索方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最著名的估计就是二分搜索了，
这种方式的前提条件是数组有序。&lt;/p&gt;
&lt;p&gt;基本思路如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
取搜索空间的中间节点；
比较该节点元素与目标元素的大小；
若目标元素的值较小，则搜索原空间的左半部分；
若目标元素值较大，则搜索原空间右半部分；
循环搜索直到找到目标元素或搜索空间为空，则搜索失败。
&lt;/pre&gt;
&lt;p&gt;二分相当于每次减少了一半的搜索空间，
整体算法复杂度下降为O(logn)，
因此搜索大范围的数据速度相当快。&lt;/p&gt;
&lt;p&gt;二分的变种相当多，
虽然基本思路类似但由于实现的功能不同导致代码存在差异。&lt;/p&gt;
&lt;p&gt;另外，
二分思路简单实现很不容易，
尤其是边界问题很喜欢出错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找了一下没有常见的纯链表快速搜索，
很多人的建议是使用二叉查找树。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;二叉查找树方式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;二叉查找树其实也是二分的思想，
对于每个节点，比较元素值，
若目标较小则搜索左子树，
若目标较大则搜索右子树，
直到找到或着遇到叶子节点。&lt;/p&gt;
&lt;p&gt;另外一种实现是哈希思想。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;哈希方式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;使用open hashing，
用数组作为哈希桶的入口节点，
凭借数组的快速定位找到入口，
数组元素指向保存内容的链表上，
最后在链表中线性查找目标元素。&lt;/p&gt;
&lt;p&gt;其实这种方式没有从本质上优化链表的搜索，
只是通过哈希去掉了大部分不同索引节点的搜索过程，
使最终需要查找的节点数量最小化，
达到加快搜索的目的。&lt;/p&gt;
&lt;p&gt;而对于最终链表的查找优化，
博主在数据结构的课本上看到一种方式，
即通过更新节点的相对位置来达到。&lt;/p&gt;
&lt;p&gt;基本思路是将常被访问的节点尽量排列在链表的前部，
较少访问的节点排在尾部，
这样，
长远来看，
总的节点遍历个数会下降。&lt;/p&gt;
&lt;p&gt;至于更新相对位置，
最简单的方式是每次找到目标元素，
就把对应节点与其前驱节点交换，
使其向链表头部靠拢。&lt;/p&gt;
&lt;p&gt;其他的还有很多种更新方式。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category><category term="data structure"></category></entry><entry><title>C++学习(六)：栈的实现及若干算法</title><link href="/CppLearning006.html" rel="alternate"></link><updated>2014-03-04T22:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-03-04:CppLearning006.html</id><summary type="html">&lt;p&gt;事情一多就需要细致分配时间，
心情一迷茫就总会没有效率，
越攒待办事项就越多。&lt;/p&gt;
&lt;p&gt;就像发送速率比入队速率慢的路由器似的。&lt;/p&gt;
&lt;p&gt;整个一丢包的赶脚。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;栈的实现&lt;/h2&gt;
&lt;p&gt;栈的实现是比较简单的，
博主使用的是线性表构造的栈，
通过复用前几篇实现的节点数据类型，
很容易就搞定栈的实现，
同时写了基本的push、pop等函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinkStack&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;protected:&lt;/span&gt;
    &lt;span class="n"&gt;Freelist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;freelist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="n"&gt;LinkStack&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;peek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;isempty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insertatbottom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkStack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;temptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;freelist&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;newnode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;temptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;LinkStack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isempty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;temptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;freelist&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;delnode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;LinkStack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;peek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isempty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;top指针指向栈的顶部，
当栈空的时候top为null。&lt;/p&gt;
&lt;p&gt;加入新节点则将新节点指向top，
再更新top使其指向新的顶端。&lt;/p&gt;
&lt;p&gt;弹出节点时作反向操作，top指向它的next，
暂存并释放原来的顶部节点。&lt;/p&gt;
&lt;p&gt;当获取或者弹出元素时需要判断栈是否为空。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;在栈底插入元素&lt;/h2&gt;
&lt;p&gt;使用线性表的话其实非常简单，
用一个指针遍历到末尾插入即可。&lt;/p&gt;
&lt;p&gt;这里使用了一种不用循环而是用递归搞定的方法。&lt;/p&gt;
&lt;p&gt;当栈不为空的时候，
首先将当前栈顶的元素暂存并pop掉，
递归调用自身，参数依然是等待插入的元素，&lt;/p&gt;
&lt;p&gt;递归终止条件是栈为空，
此时插入栈底其实就是push。&lt;/p&gt;
&lt;p&gt;完成下层的递归调用再将暂存的元素push回去。&lt;/p&gt;
&lt;p&gt;这样就可以通过push、pop及isempty三个操作完成栈底的插入。&lt;/p&gt;
&lt;p&gt;同时对于使用数组实现的栈，
这种实现方式也可以成功。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkStack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;insertatbottom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isempty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;peek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;insertatbottom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;递归完成栈的逆转&lt;/h2&gt;
&lt;p&gt;使用了上述的栈底插入函数协助完成。&lt;/p&gt;
&lt;p&gt;递归的思路是这样的，
当栈不为空的时候，
首先将当前顶端节点暂存，
然后递归调用自身让剩下的子栈逆转，
最后将自身节点插入到栈底。&lt;/p&gt;
&lt;p&gt;这种递归会逐层深入到栈底，
在栈为空的时候停止递归并返回。
最后逐层上升并将元素逐个插入到栈底，
完成整个栈的逆转。&lt;/p&gt;
&lt;p&gt;博主能力有限，递归这种东西总感觉有点说不清道不明。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;LinkStack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;peek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;insertatbottom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;检测括号匹配&lt;/h2&gt;
&lt;p&gt;这是栈的一个用途，
检测一段文本中括号是否匹配。&lt;/p&gt;
&lt;p&gt;基本算法是很好理解的，
扫描整个文本:&lt;/p&gt;
&lt;p&gt;1.遇到左括号('(','['及'{')则将其push入栈。&lt;/p&gt;
&lt;p&gt;2.遇到右括号将其与栈顶元素比较，
如果匹配则将对应括号弹出删掉;
否则直接就检测出匹配失败。&lt;/p&gt;
&lt;p&gt;3.扫描完成，
如果栈非空，
说明还有一些左括号没有被匹配，
则匹配失败;
否则匹配成功。&lt;/p&gt;
&lt;p&gt;4.还有一种情况，
扫描过程中找到右括号，
但栈已空，
则无法匹配右括号，
同样判定为匹配失败。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;mapchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;:&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;[&amp;#39;&lt;/span&gt;:&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;{&amp;#39;&lt;/span&gt;:&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nl"&gt;default:&lt;/span&gt; &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//......&lt;/span&gt;

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;{&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
            &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;[&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
            &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;check&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;peek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;mapchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;check&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isempty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="n"&gt;check&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用于检测的字符串全部都是括号，
因此没有添加判定括号的代码，
直接扫描过去。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;检测下一个较大的元素&lt;/h2&gt;
&lt;p&gt;给定一个数组，
要求找出对于数组中的每一个元素下一个更大的元素。&lt;/p&gt;
&lt;p&gt;一般的方法是暴力搜索，
对于每一个元素遍历一遍剩余元素，
每次比较并找出第一个更大的元素。&lt;/p&gt;
&lt;p&gt;时间复杂度是O(n^2)&lt;/p&gt;
&lt;p&gt;一个更优的办法是使用栈，
同样遍历数组：&lt;/p&gt;
&lt;p&gt;对于每一个元素current，
将其与栈顶的元素top依次比较，
若栈顶元素top较小，则弹出top，
并确定该top元素的下一个较大元素就是当前检测的元素current;&lt;/p&gt;
&lt;p&gt;继续比较栈顶元素top1，top2......
直到栈空或者找到topn比current大，
此时将current推入栈。&lt;/p&gt;
&lt;p&gt;逐项处理数组，直到完成。&lt;/p&gt;
&lt;p&gt;此时栈中剩余的元素就是没有下一个较大元素的那些，
按要求处理之。&lt;/p&gt;
&lt;p&gt;时间复杂度是O(n)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//ptr:遍历数组的指针&lt;/span&gt;
&lt;span class="c1"&gt;//buf:输入数据的缓冲数组&lt;/span&gt;
&lt;span class="c1"&gt;//size:buf数组大小&lt;/span&gt;
&lt;span class="c1"&gt;//curelement:当前栈顶的元素&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;curelement&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;peek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curelement&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curelement&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d -&amp;gt; %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curelement&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;peek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curelement&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d -&amp;gt; -1&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curelement&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stock-span"&gt;
&lt;h2&gt;Stock Span问题&lt;/h2&gt;
&lt;p&gt;搞不清楚是什么意思，
google说这个字面上叫做”股票跨度“，
莫名其妙。&lt;/p&gt;
&lt;p&gt;总之，将所有乱七八糟的描述全部去掉，
问题就归结为，
给定一个数组，
对于每个元素，
计算在其之前的所有连续的比该元素小的元素总数。&lt;/p&gt;
&lt;p&gt;例如数组{100, 80, 60, 70, 60, 75, 85},
则计算结果为{1, 1, 1, 2, 1, 4, 6}&lt;/p&gt;
&lt;p&gt;一般方法自然是暴力搜索，不再赘述。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;突然想到一句经典的话：“拿不准，就穷举！”(When in doubt, use brute force)&lt;/p&gt;
&lt;p&gt;谁说的来着...Ken Thompson!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回到栈，
实现的方式类似上面的算法，
不过这次需要保存一些额外的信息。&lt;/p&gt;
&lt;p&gt;遍历数组，
对于每个元素current，
初始化计算值为1（自身），
比较栈顶元素top1的大小，
若比该current小，
则将current的计算值加上top的计算结果。
弹出top1，继续比较top2，top3...
直到栈空或找到topn比current大。&lt;/p&gt;
&lt;p&gt;保存current的最终计算结果，
将current推入栈，
继续遍历。&lt;/p&gt;
&lt;p&gt;刚发现代码可以优化，
太晚了，下次再搞。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Stock&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//保存计算值&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//保存在原始数组中对应的索引值&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;//curvalue: 当前元素的计算值&lt;/span&gt;
&lt;span class="c1"&gt;//curstock: 当前栈顶元素&lt;/span&gt;
&lt;span class="c1"&gt;//price: 保存所有原始数值的数组&lt;/span&gt;
&lt;span class="c1"&gt;//result: 保存所有计算结果的数组&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;curvalue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;peek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curstock&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;price&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;curstock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;price&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;curvalue&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;curstock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curvalue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;curstock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;curstock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curvalue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curstock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Result:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;搞定，睡觉。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category><category term="data structure"></category></entry><entry><title>C++学习(五)：有序线性表的点滴记录</title><link href="/CppLearning005.html" rel="alternate"></link><updated>2014-02-25T16:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-02-25:CppLearning005.html</id><summary type="html">&lt;p&gt;在线性表的基础上开始构建有序线性表。
使用的是单next指针结构的线性表。&lt;/p&gt;
&lt;p&gt;后续将考虑在数组的基础上构建能够高效插入和搜索的数据结构。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;基本结构&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SortedLinklist&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;comp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="nl"&gt;protected:&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;insertafter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;comparefunc&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;mergewithotherlist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;removeduplicates&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;intersectionwith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;anotherlist&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从基类直接继承了内置的链表数据结构，
在此基础上首先屏蔽了部分随机插入的函数接口，转为protected，
其次重载了基类的插入函数，
提供有序插入的功能。&lt;/p&gt;
&lt;p&gt;其次，
添加了一个protected的函数指针成员，
在构造函数中接收外部传入的比较函数指针，
并储存到该成员中。
达到的目的是可以自定义排序，
此举是收到STL中qsort的启发，
其实标准库中的很多东西都能够自定义比较函数。&lt;/p&gt;
&lt;p&gt;最后加入了若干有序线性表独有的新函数，
合并，去重，以及查找与另一有序线性表的交集。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;有序的实现&lt;/h2&gt;
&lt;p&gt;非常简单的做法，
在插入新元素时，
从头部开始搜索直到找到一个比该元素大的元素，
或者找到链表末尾，
那么就在该节点前插入目标元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;comparefunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tempnex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;freelist&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;newnode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tempnex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;合并两个有序线性表&lt;/h2&gt;
&lt;p&gt;基本套路是从两个表的头开始，
每次比较当前的两个指针，
将小的提取出来并将对应指针往前移动。
直到某个指针到达尾部。&lt;/p&gt;
&lt;p&gt;最后处理剩下的(如果有)另一个链表的剩余元素，
全部接到新的链表中即可。&lt;/p&gt;
&lt;p&gt;博主的解决方案将传入的链表节点全部有序插入到原链表中，
最终的结果是两个链表合并为同一个链表，
传入的链表将被清空。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;mergewithotherlist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;listptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;listptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//two pointer for each list and one for the new list.&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptra&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;listptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptrb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;traveller&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//merge, smaller first&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptra&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ptrb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;comparefunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptra&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptrb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;traveller&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptrb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;ptrb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptrb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;traveller&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptra&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;ptra&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptra&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;traveller&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;traveller&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//some nodes left, append to the end of list&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptra&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;traveller&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptra&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptrb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;traveller&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptrb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//clear the other list&lt;/span&gt;
    &lt;span class="n"&gt;listptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;去重的实现&lt;/h2&gt;
&lt;p&gt;目标是去除所有重复的元素。
处理的方式是遍历链表，
将所有与前一个元素相同的元素节点删除。&lt;/p&gt;
&lt;p&gt;需要关注一下头节点，
以及链表为空的情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SortedLinklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;removeduplicates&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nexptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nexptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;comparefunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nexptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nexptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;freelist&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;delnode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nexptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nexptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;nexptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;检测与其他有序链表的交集&lt;/h2&gt;
&lt;p&gt;由于是有序的因此比较简单，
方法类似于合并，但这里是找到所有相同的元素。&lt;/p&gt;
&lt;p&gt;因此使用两个指针，从头部开始，
依次比较指针指向的元素，
如果相同，则找到一个相交的节点，记录;
如果不同，则指向小元素的指针前移。
直到某个指针指向表尾。&lt;/p&gt;
&lt;p&gt;博主在敲代码的时候忘记在找到相交元素后两个指针需要同时前移，
卡了一段时间。
因此做事还是要小心谨慎为好。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;taila&lt;/span&gt;  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;tailb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;comparefunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;taila&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tailb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;cp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;newtail&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;freelist&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;newnode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;taila&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;newtail&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newtail&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;taila&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;taila&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;tailb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tailb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;tailb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tailb&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;taila&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;taila&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;杂记&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关于this指针&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;遇到一个犄角旮旯的问题：&lt;/p&gt;
&lt;p&gt;在类模板的情况下，
子类继承父类，
在子类中调用父类的protected或public成员时，
需要显式指定this指针，
否则编译报错，
g++中显示未声明的符号。&lt;/p&gt;
&lt;p&gt;博主被这个问题卡了一段时间，
测试时将变量复制并粘贴一遍到子类中则可以解决问题，
否则一直显示未声明符号。&lt;/p&gt;
&lt;p&gt;最后在stackoverflow上找到了问题的答案。&lt;/p&gt;
&lt;p&gt;由于涉及到编程语言C++的内部结构问题，
貌似有点复杂，
因此没有找到问题的原理。&lt;/p&gt;
&lt;p&gt;反正加一个this-&amp;gt;就可以了。
(-_-)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category><category term="data structure"></category></entry><entry><title>C++学习(四)：线性表的奇技淫巧(二)</title><link href="/CppLearning004.html" rel="alternate"></link><updated>2014-02-16T21:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-02-16:CppLearning004.html</id><summary type="html">&lt;p&gt;这两天去玩了，
进度比较慢。&lt;/p&gt;
&lt;p&gt;无序线性表终于算是搞了个大概，
有些过于繁琐的就没有管了。&lt;/p&gt;
&lt;p&gt;准备入手有序线性表，
把一些牛逼的算法也弄进去，
二分、堆排序、归并排序什么的。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;奇技淫巧大收集（续）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线性表判环&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就是判别一个线性表中有没有出现环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单标记方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几种标记都可以。&lt;/p&gt;
&lt;p&gt;如果是不重复的整数并且范围比较小的话，
直接开个bool型的数组，用下标表示某个特定的数，
对应值为1指定该值出现过，
对应值为0指定该值没有出现。&lt;/p&gt;
&lt;p&gt;整数下标的数组搞不定则可以考虑弄个标准库的哈希表。&lt;/p&gt;
&lt;p&gt;总之，思路就是遍历链表，
把出现过的标记起来，
当遍历过程中再次碰到被标记过的节点说明链表有环，
否则肯定能搜索到链表的表尾并结束。&lt;/p&gt;
&lt;p&gt;需要一些额外的空间及计算量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Floyd方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感觉搞数学的家伙总能找到一些神奇的方法解决某些奇怪的问题。&lt;/p&gt;
&lt;p&gt;开两个指针fast, slow，均初始化为头节点，
fast每次移动两个节点，slow每次移动一个节点。&lt;/p&gt;
&lt;p&gt;单步运行，直到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、fast指针到达表尾，无环；&lt;/p&gt;
&lt;p&gt;2、fast指针与slow指针在某一步指向同一个节点，有环；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;线性表除环&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单办法就直观了，
直接每个节点检查，
很蠢，不详谈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高效方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，用上述的Floyd算法找到环，
这个时候fast指针(或者slow指针)肯定是在环里面的某个节点。&lt;/p&gt;
&lt;p&gt;利用这个特性，统计，用指针移动统计环中节点的个数，假定为n。&lt;/p&gt;
&lt;p&gt;显而易见，
环的出现肯定是在链表的尾部，
因此去除环相当于将链表的尾节点与环中的连接节点切断。&lt;/p&gt;
&lt;p&gt;那么尾节点现在与哪个节点相连呢？
明显是倒数第n个，因为环有n个节点。&lt;/p&gt;
&lt;p&gt;再利用上一篇博文讲过的从头指针查找倒数第n个节点的办法，
加以变通，
当两个指针在某次移动中指向同一个节点的时候，
说明那里是环的入口。&lt;/p&gt;
&lt;p&gt;接下去就简单了，找到入口就找到了尾节点，
把它的next赋值为0即可搞定。&lt;/p&gt;
&lt;p&gt;太麻烦了博主就没实现... -_-&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;逆向输出&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不同于直接逆向链表，
这个只是逆向输出所有值，链表本身没有变化。&lt;/p&gt;
&lt;p&gt;方案其实不复杂，
递归嘛，谁不会。&lt;/p&gt;
&lt;p&gt;实现的时候偷懒，
不想搞两个函数一个内部递归一个外部调用，
因此用了一个默认参数0给curptr初始值，
外部调用时只传入第一个函数指针用于输出。&lt;/p&gt;
&lt;p&gt;检测到节点指针为0说明是外部第一次调用，
指针初始化为头节点。&lt;/p&gt;
&lt;p&gt;否则说明是递归过程，
则做对应处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;listprintreverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;curptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;listprintreverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;listprintreverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;旋转链表&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以某个节点旋转链表，
比如1-2-3-4-5,
以节点2旋转，则变成3-4-5-1-2&lt;/p&gt;
&lt;p&gt;用链表实现这货就非常简单啦，
头尾指针处理一下即可搞定。&lt;/p&gt;
&lt;p&gt;不过要注意边界情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;rotatefrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ind&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_getnth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getend&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;关于输出&lt;/h2&gt;
&lt;p&gt;由于使用了模板，
无法确定节点的值是什么类型，
因此在处理遍历输出的时候就没法在类模板中把输出语句预先定义死。&lt;/p&gt;
&lt;p&gt;使用函数指针解决这个问题，
从外部传入输出特定类型节点值的函数，
遍历函数直接调用外部传入的函数进行最终的输出工作。&lt;/p&gt;
&lt;p&gt;第一次使用C++的函数指针，还是蛮好玩的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;listprint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category><category term="data structure"></category></entry><entry><title>C++学习(三)：线性表的奇技淫巧(一)</title><link href="/CppLearning003.html" rel="alternate"></link><updated>2014-02-11T21:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-02-11:CppLearning003.html</id><summary type="html">&lt;p&gt;在Github上建了一个新仓库练习数据结构，
地址在这里：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://github.com/scutLaoYi/data-structure"&gt;https://github.com/scutLaoYi/data-structure&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;clone的话记得在后面加.git后缀(没什么好clone的)。&lt;/p&gt;
&lt;p&gt;我觉得莫名其妙的是代码类型居然被判为57%的C、25%的C++，
以及18%的Objective-C。&lt;/p&gt;
&lt;p&gt;学习的资料上一篇博文已经说过了，是个好地方。&lt;/p&gt;
&lt;p&gt;从线性表学起，实现了资料里说的一些问题，
光看不写的话感觉倒是容易看懂，不过真的写起来总是一大堆问题。&lt;/p&gt;
&lt;p&gt;上哪都一样。&lt;/p&gt;
&lt;p&gt;线性表才看了一半不到，
总结一下自己用的一些实现方法及若干这几天见到的牛逼技术。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;数据结构的实现&lt;/h2&gt;
&lt;p&gt;自己的实现方案使用了类模板，
首先定义了一个节点的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;包含一个节点值及一个指向下一个节点的指针。
构造函数用于初始化指针，赋值为0。&lt;/p&gt;
&lt;p&gt;然后搞了一个freelist用于处理内存。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Freelist&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="n"&gt;Freelist&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Freelist&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;*&lt;/span&gt; &lt;span class="n"&gt;newnode&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;delnode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个搞法是以前学习数据结构大作业的时候了解到的，
delete和new的效率比较低，
因此自定义了节点的申请和释放，
用一个自由链表储存所有闲置的节点，
当某个节点被删除的时候暂存到自由链表里，
当需要新节点的时候先去看有没有空闲的，
没有再new新的节点。&lt;/p&gt;
&lt;p&gt;带来的坏处是内存的占用会比较大。&lt;/p&gt;
&lt;p&gt;在此基础上开始构建线性表。&lt;/p&gt;
&lt;p&gt;此外需要注意的是类模板的实现问题，
以前也遇到过结果时间长了又给忘了。
简单说来不能把template的实现放在cpp文件中，
不然编译的时候会出现符号错误。
最方便的处理方式是把实现贴到头文件的下面去，
去掉cpp文件。&lt;/p&gt;
&lt;p&gt;我记得不同编译器对这个问题的解决方案有些差异，
以前用VC++编译器的时候是在需要使用模板的文件里，
把cpp文件也include进去。
不过这种做法在g++里貌似搞不定，
最终把东西都扔进头文件里了事。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;线性表&lt;/h2&gt;
&lt;p&gt;类的结构倒是非常简单，
搞一个自由链表用于处理节点，
保存一个头节点的指针即可。&lt;/p&gt;
&lt;p&gt;博主的搞法是用一个空值的节点作为头节点，
头节点的nex指针指向第一个有值的节点，
如果链表为空的话头节点的nex指向null。
与教学材料中的不同，
这种搞法的好处是头节点将永远存在，
因此少了非常多的特判，
也不容易出错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Linklist&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Freelist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;freelist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现了几个私有的函数用于处理常见的操作，
简化代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step步进函数，
让指针指向自身的nex，
返回布尔值指示结果。&lt;/p&gt;
&lt;p&gt;其他的还包括getend函数获取链表尾节点，
_getnth函数获取某个特定的节点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;奇技淫巧大收集&lt;/h2&gt;
&lt;p&gt;接下来就是若干特定问题处理的收获了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取链表中间位置值&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题在数组里非常容易处理，
直接长度的一半去偏移头指针即可。&lt;/p&gt;
&lt;p&gt;但是在没有保存链表长度的线性表中就比较麻烦，
因为不知道长度所以没有办法知道哪一个是链表中间位置的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单方案非常直观，
首先遍历链表，数一遍知道链表总长度，
算出中间位置是哪个，
然后再遍历链表到中间位置即可。&lt;/p&gt;
&lt;p&gt;简单方案感觉有点蠢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高效方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个指针，均从头节点开始，
一个快的指针每次移动两个节点，
一个慢的指针每次移动一个节点。&lt;/p&gt;
&lt;p&gt;当快的指针移动到链表尾部的时候，
慢的指针刚好就在链表的二分之一的位置。&lt;/p&gt;
&lt;p&gt;要多考虑一些边界情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;getmiddle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;slow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fast&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;slow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;slow&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;slow&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;获取倒数第n个节点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同样，数组的话算一下偏移量直接就出来了。
对于没有长度记录的线性表还是难搞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样是先遍历一遍数长度，
得到长度后再找到目标节点。
根据长度判一下有没有倒数第n个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高效方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是两个指针，
一个在头，
一个在头指针后n个节点的位置。&lt;/p&gt;
&lt;p&gt;同时移动两个指针，每次一个节点，
直到后面那个指针到达线性表的尾部，
此时前面的指针就指向了倒数第n个节点。&lt;/p&gt;
&lt;p&gt;如果一开始就没办法移动到第n个位置则说明线性表没那么长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;getnthfromend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mainptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;referptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;mainptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_getnth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;referptr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;referptr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mainptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mainptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;反转链表&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就是整个反过来，
数组的话有多种方案可以搞，
比如搞个缓冲区，
两个指针分别从头尾向中间移动，
每次交换两个指针的值，
那么可以交换n/2次，占用额外一个空间搞定。&lt;/p&gt;
&lt;p&gt;链表的话...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;额外的O(n)空间作缓冲区，
遍历一遍原链表，
把内容暂存到缓冲区中，
再遍历一遍链表把内容反向刷新进去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高效方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建三个指针，
prev, cur, nex。&lt;/p&gt;
&lt;p&gt;直接操每个节点的nex指针，
遍历链表，
每次将cur-&amp;gt;nex赋值给nex，保存下一个需要处理的节点；
将prev赋值给cur-&amp;gt;nex，把当前指针的nex反向指向父节点；
将cur赋值给prev，nex赋值给cur，移动并处理下一个节点。&lt;/p&gt;
&lt;p&gt;最终最后一个节点变成头节点，搞定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//have some more to deal with&lt;/span&gt;
            &lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="c1"&gt;//reach the end of the list&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写这货还学了一下vim操剪贴板的技术，
研究了有些时日现在终于有比较好的解决方案了，
下次来记录一下。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category><category term="data structure"></category></entry><entry><title>C++学习(二)：大家一起来Makefile</title><link href="/CppLearning002.html" rel="alternate"></link><updated>2014-02-08T16:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-02-08:CppLearning002.html</id><summary type="html">&lt;p&gt;由于一直没找到好的材料，C++的学习拖了好几天没什么进展。
主要遇到的问题是白书的题目(UVAoj)有些麻烦，之前刷了十几道水题一直很顺利，
到了数据结构系列突然每道题都有点难以理解（难道是自己英语水平突然掉了...），
刷了几天进展很慢，加上每道题都有针对性的代码，对于我这种目标是复习数据结构的不太合适。&lt;/p&gt;
&lt;p&gt;然后玩了两天JavaScript（每页一句模块实现），玩了一天游戏...&lt;/p&gt;
&lt;p&gt;找到一个好地方学习数据结构：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="http://www.geeksforgeeks.org/data-structures/"&gt;http://www.geeksforgeeks.org/data-structures/&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;今天开始敲了一下线性表，过几天再写点总结。&lt;/p&gt;
&lt;p&gt;然后终于到了这篇的主题，makefile的编写。&lt;/p&gt;
&lt;div class="section" id="make"&gt;
&lt;h2&gt;make&lt;/h2&gt;
&lt;p&gt;所谓的make，是便于编译多个文件的工具，用make可以实现自动化构建软件。
同时使用make可以根据依赖关系自动编译，简化手工操作。
具体的介绍可以查一下make的手册页。&lt;/p&gt;
&lt;p&gt;很多的IDE现在都实现了make的功能，
比如之前用过的Visual Studio系列，Code::block，甚至是Qt SDK的开发环境，
只要建立一个工程，就可以让IDE自动完成多文件编译和依赖检查。&lt;/p&gt;
&lt;p&gt;但Linux下的很多软件还是使用make协助软件的部署，
而像博主这种懒得用IDE的家伙，
手头就一个Vim写代码，一个g++编译（写C++的话），
有时用用gdb调试一番（更多时候是暴力调试...)，
再用上方便的make其实也就差不多了。&lt;/p&gt;
&lt;p&gt;开源社区中也有许多软件是用make的，
就像博主这个网站使用的Pelican，
从源文档加载主题文件（CSS，JS等）转换成静态的HTML页面，
这个过程就使用了make，从而省去了大量的重复命令。&lt;/p&gt;
&lt;p&gt;make默认情况下读取当前文件夹中的makefile文件，
makefile相当于配置文件，
指导make执行命令完成目标代码的编译。&lt;/p&gt;
&lt;p&gt;make不限于特定的语言，
博主把它放在C++栏目中是因为历史上很多很多人用make协助编译C/C++代码。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
假设要编译三个文件：main.cpp test.h test.cpp，输出为a.out
那么默认情况下每次要这样写：
g++ main.cpp test.h test.cpp -o a.out
如果写好了makefile，每次只需要这样：
make
并且会自动检查依赖，忽略某些未改变的项，提高编译速度
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;获取make&lt;/h2&gt;
&lt;p&gt;据称很多Linux发行版中都自带了make，
我不知道其他人的是什么情况，
反正博主手头的Arch Linux没有...(=_=)&lt;/p&gt;
&lt;p&gt;不过不要紧，pacman -S装一下就有了，非常方便&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="makefile"&gt;
&lt;h2&gt;makefile文件的编写&lt;/h2&gt;
&lt;p&gt;makefile文件的基本语法如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[target]:[dependencies]
[tab]   command
&lt;/pre&gt;
&lt;p&gt;其中target为目标，调用命令make时指定目标即可实现不同的执行过程。&lt;/p&gt;
&lt;p&gt;dependencies为依赖项，make执行时首先检查对应目标的依赖是否满足，
如果搜索到存在对应的文件，且在上次执行后没有被更改，则认定该项依赖满足，
否则搜索查找对应依赖项的目标并首先执行它，获取目标依赖。
当所有依赖满足后执行最终目标。&lt;/p&gt;
&lt;p&gt;tab就是一个tab制表符。&lt;/p&gt;
&lt;p&gt;command才是最终被执行的命令语句，如&amp;quot;g++ main.cpp -o a.out&amp;quot;之类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个最简单的makefile&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
all:
    g++ main.cpp test.h test.cpp -o a.out -Wall -g
&lt;/pre&gt;
&lt;p&gt;all是默认make的目标。
上面这两行定义了最简单的makefile，将它保存并执行如下语句：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make
&lt;/pre&gt;
&lt;p&gt;make后不加参数，因此make执行makefile文件;
由于没有设定目标，因此选择默认目标all;
由于all目标没有依赖项，因此可以直接执行;
最终那句g++被执行，完成编译（输出a.out，显示警告，添加debug信息用于gdb调试）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多目标带依赖项的makefile&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
all: main

main: main.o test.o
    g++ main.o test.o -o a.out -Wall -g

main.o: main.cpp
    g++ -c main.cpp

test.o: test.cpp test.h
    g++ -c test.h test.cpp
&lt;/pre&gt;
&lt;p&gt;基本上一目了然，
默认目标依赖main目标，
mian目标依赖main.o和test.o，
两个o文件依赖对应的源文件和头文件。&lt;/p&gt;
&lt;p&gt;这种情况下首次执行make，由于所有依赖都不满足，
因此最先被执行的是编译main.cpp，
其次执行编译test.cpp和test.h，
最后编译出a.out。&lt;/p&gt;
&lt;p&gt;而在所有文件都没有变化的情况下再次执行make，
由于两个依赖都存在，
因此只有编译a.out的那句被执行了一次。&lt;/p&gt;
&lt;p&gt;make自动检测文件变化，
因此会自动重新编译被修改过的文件。&lt;/p&gt;
&lt;p&gt;此外，还可以指定make目标以编译部分文件，指定目标的命令如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make main.o
&lt;/pre&gt;
&lt;p&gt;这句指定编译main.o目标。&lt;/p&gt;
&lt;p&gt;如果目标已经存在并且是最新，则make会提示：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make: 'main.o' is up to date.
&lt;/pre&gt;
&lt;p&gt;插句话，-c选项让g++编译并不链接文件，生成的文件为原文件名替换上.o后缀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带参数和注释的makefile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在makefile中指定参数，
同时可以写注释。&lt;/p&gt;
&lt;p&gt;感觉比较简单，贴个例子就可以了：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#这是注释，用井号开头就可以了
#声明参数要像下面这样
OUTPUT=a.out
#使用的话是这样：

all:
    g++ main.cpp -o $(OUTPUT) -Wall -g
&lt;/pre&gt;
&lt;p&gt;上面的例子就定义了输出文件名参数，
这样在多个地方都可以通过“钱+小括号”的形式使用参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不想用makefile做文件名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随便搞，只要在make的时候麻烦一点给个参数指定文件名即可：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make -f my_makefile
&lt;/pre&gt;
&lt;p&gt;使用my_makefile文件作为配置文件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;make的各种功能&lt;/h2&gt;
&lt;p&gt;学会写makefile之后应该能够看出来，
make其实是通过构造shell命令执行功能的，
因此发挥想象力，用make可以搞定非常多的东西。&lt;/p&gt;
&lt;p&gt;一个非常简单的例子是自动清空当前文件夹的编译过程文件：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
all:
#......

clean:
    rm -rf *.o *.gch
&lt;/pre&gt;
&lt;p&gt;这样，执行&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make clean
&lt;/pre&gt;
&lt;p&gt;即可搞定清扫工作。&lt;/p&gt;
&lt;p&gt;当然&amp;quot;rm -rf&amp;quot;是比较狠的，使用要小心。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category></entry><entry><title>C++学习(一):白书基础总结</title><link href="/CppLearning001.html" rel="alternate"></link><updated>2014-01-31T16:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-31:CppLearning001.html</id><summary type="html">&lt;p&gt;装完Arch Linux最近开始复习一下C++和数据结构，为下学期做好准备。&lt;/p&gt;
&lt;p&gt;用白书刷一些简单的题目复习基本语法，发现自己太不注重基本的东西了，之前瞎搞ACM的时候也是，好多方便有效的工具都不认识。&lt;/p&gt;
&lt;p&gt;因此记录一下标准库的一些基本的工具和输入输出的简单总结。&lt;/p&gt;
&lt;p&gt;本篇主要记录一些C语言的常用工具。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;输入输出及文件操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;scanf&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这货读取输入并对相应的内存地址赋值。
分割符是空格、回车及制表符等。&lt;/p&gt;
&lt;p&gt;返回值是一个整型表示成功读取到的数据量。
读取失败或者EOF文件结束都会停止。&lt;/p&gt;
&lt;p&gt;默认情况下scanf不会吃掉行尾的回车，
需要让它吃掉行尾回车的话可以这样：&lt;/p&gt;
&lt;p&gt;scanf(&amp;quot;%d\n&amp;quot;, &amp;amp;num)&lt;/p&gt;
&lt;p&gt;上面这句首先读了一个整型值给变量num，并且吃掉了后面的一个\n&lt;/p&gt;
&lt;p&gt;当然这种搞法的缺陷在于只能用于Linux类型系统，
因为windows和Mac OS的回车符都不一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;sscanf/fscanf&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;scanf的姊妹版本，分别读取字符串或者文件。&lt;/p&gt;
&lt;p&gt;sscanf使用的时候加入第一个参数指定输入的源字符串。&lt;/p&gt;
&lt;p&gt;fscanf使用的时候加入第一个参数指定输入的源文件指针。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;fgets(buffer, size, source)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从输入源source中读入一行字符数据到buffer缓冲区中，最大长度为size。
超过size部分会被忽略。&lt;/p&gt;
&lt;p&gt;buffer为一个char数组，size为整型值定义长度。&lt;/p&gt;
&lt;p&gt;source可以为文件等，默认的终端标准输入(standard input)是这个： stdin&lt;/p&gt;
&lt;p&gt;fgets与scanf混用的话由于scanf默认不吃掉行尾回车，会导致scanf之后fgets第一行没有内容。
处理方法就是上面说的改进版本scanf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;fgetc(source)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从source中读取一个字符并返回。
注意返回值是int。&lt;/p&gt;
&lt;p&gt;使用fgetc需要检查返回值不是EOF，然后再转换为char获取得到的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;重定向版本的文件操作&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从文件读取数据可以使用多种方法，
最简单的是输入重定向，
将stdin指向文件。&lt;/p&gt;
&lt;p&gt;一、&lt;/p&gt;
&lt;p&gt;freopen(&amp;quot;filename&amp;quot;, &amp;quot;r&amp;quot;, stdin);&lt;/p&gt;
&lt;p&gt;将filename文件以读(r)方式打开，并重定向到stdin中。
后续的操作便可以直接scanf搞定。&lt;/p&gt;
&lt;p&gt;同样，输出也可以这么搞：&lt;/p&gt;
&lt;p&gt;freopen(&amp;quot;outputfilename&amp;quot;, &amp;quot;w&amp;quot;, stdout);&lt;/p&gt;
&lt;p&gt;二、&lt;/p&gt;
&lt;p&gt;此外，白书没有说的一种方式是直接在终端里运行程序的时候重定向。&lt;/p&gt;
&lt;p&gt;./a.out &amp;lt; data &amp;gt; out&lt;/p&gt;
&lt;p&gt;其中a.out是可执行文件，利用&amp;lt;将data数据文件作为输入，利用&amp;gt;将输出重定向到out文件&lt;/p&gt;
&lt;p&gt;这种搞法的好处是随时可以指定输入输出，不用重新编译。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文件流版本的文件操作&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准的文件操作，包含打开文件、操作文件和关闭文件。&lt;/p&gt;
&lt;p&gt;FILE * fin = fopen(&amp;quot;filename&amp;quot;, &amp;quot;mode&amp;quot;)&lt;/p&gt;
&lt;p&gt;打开filename文件，mode可以为r或者w，加上b的话貌似是二进制方式操作。
返回值是一个FILE *类型的指针，指向打开的文件。&lt;/p&gt;
&lt;p&gt;用fscanf替换scanf，添加第一个参数指定输入的文件指针，例如：&lt;/p&gt;
&lt;p&gt;fscanf(fin, &amp;quot;%d&amp;quot;, &amp;amp;num)&lt;/p&gt;
&lt;p&gt;从fin这个FILE *中读取一个整型值给num变量&lt;/p&gt;
&lt;p&gt;fgets的话直接就可以用了：&lt;/p&gt;
&lt;p&gt;fgets(buf, size, fin)&lt;/p&gt;
&lt;p&gt;最后记得关闭文件&lt;/p&gt;
&lt;p&gt;fclose(fin)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;printf/sprintf/fprintf&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
相当那个scanf三兄弟，不再赘述。&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;标准库的一些方便的工具&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;cstring&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串一类的操作就不用说了，strcmp啦strcpy啦strcat啦都非常方便。&lt;/p&gt;
&lt;p&gt;此外strstr返回目标串中某子串最早出现位置的指针，有时能有奇效。&lt;/p&gt;
&lt;p&gt;这里主要想记录的是两个内存操作的工具：&lt;/p&gt;
&lt;p&gt;memset(void *ptr, int value, size_t size)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查了相关的资料，memset是按字节操作的，虽然传入的value是一个int，
但处理的时候会被转换成unsigned char进行赋值。&lt;/p&gt;
&lt;p&gt;因此处理字符数组是没有问题的，比如给一个字符数组刷二十个字符'a':&lt;/p&gt;
&lt;blockquote&gt;
memset(target, 'a', 20)&lt;/blockquote&gt;
&lt;p&gt;但是处理数字的时候就存在问题了，例如常用的int占四个字节，照着原理来讲0或者-1是可以的。
因为按照数字的储存方式（补码）来说，0的话所有位都是0，-1的话所有位都是1，
刚好绕过了int与byte之间的大小区别。
因此可以用memset刷int型数组：&lt;/p&gt;
&lt;blockquote&gt;
memset(numAry, 0, sizeof(numAry)) //将数组的所有元素刷成0&lt;/blockquote&gt;
&lt;p&gt;这里就需要注意刷的内存块的大小，
因为是按字节操作，因此总的大小应该是每个int的大小(sizeof(int))乘上需要刷的元素个数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;memcpy(void *dis, void *source, size_t size)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;仍然是按字节操作，
从source指针指向的地址开始，
将size个字节复制，
存储到从dis指向的地址开始的后size个字节。&lt;/p&gt;
&lt;p&gt;由于这货直接操某块内存，因此不仅能用于复制数组：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int ary1[] = {1,2,3,4,5};
int ary2[5];
memcpy(ary2, ary1, sizeof(int) * 5);
&lt;/pre&gt;
&lt;p&gt;还能直接搞结构体：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct MyStr{
    int num,
    char str[100]
};
MyStr str1, str2;
//...
memcpy(&amp;amp;str2, &amp;amp;str1, sizeof(str1));
&lt;/pre&gt;
&lt;p&gt;注意要取址符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;cctype&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这货非常方便，拥有一堆检测的库函数。&lt;/p&gt;
&lt;p&gt;常用的有以下几个：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
isdigit:检测是否数字
isalpha:检测是否字母（含大小写）
isupper:检测是否大写字母
islower:检测是否小写字母
&lt;/pre&gt;
&lt;p&gt;还有俩牛逼的货色：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
toupper:将字母转换成大写
tolower:将字母转换成小写
&lt;/pre&gt;
&lt;p&gt;博主比较懒，有时不检测就直接tolower操数据，
发现这货健壮性很好，数字什么的进去也就原样出来，不会死掉，方便！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;cstdio&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面说的输入输出基本都是这个库的东西。&lt;/p&gt;
&lt;p&gt;此外还有一个有用的函数：&lt;/p&gt;
&lt;blockquote&gt;
feof(source)&lt;/blockquote&gt;
&lt;p&gt;检测source源是否为EOF状态。
source可以是文件指针也可以是stdin。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;cstdlib&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个用得多的是快排：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void qsort (void* base, size_t num, size_t size,
        int (*compar)(const void*,const void*));
&lt;/pre&gt;
&lt;p&gt;然后在写这篇博文的时候发现居然还有这个：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void* bsearch (const void* key, const void* base,
               size_t num, size_t size,
              int (*compar)(const void*,const void*));
&lt;/pre&gt;
&lt;p&gt;随机数，常用的，先用时间作为随机种子，然后用库函数获取随机值：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
//首先需要包含ctime头文件
//然后将当前时间作为随机种子
srand(time(NULL));
//获取一个小于100的随机值
int randVal = rand() % 100
&lt;/pre&gt;
&lt;p&gt;rand函数随机值的范围与库的实现有关，但可以保证最小值为0，最大值不小于32767的整数&lt;/p&gt;
&lt;p&gt;越看越神奇，还有一堆字符串转换的函数，以后处理字符串都调标准库算了：
atoi, atof, atol......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好多东西，记多也记不住，还是要多在实践中应用。&lt;/p&gt;
&lt;p&gt;发现写博客的好处在于,当你要讲明白一个东西时，要花更多的时间去搞清楚这货的各个方面。
有时第一次使用的时候只是知道能这么用，但在写博客的时候却要弄清楚更深入一些的原理。
既有助于加深理解，也有助于整理思路。&lt;/p&gt;
&lt;p&gt;不过博主整天只会写一些基础学习，东拼西凑再随便写点个人理解～ (=_=)&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;最后，大年初一，大家新年快乐！ (^_^)&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category></entry></feed>