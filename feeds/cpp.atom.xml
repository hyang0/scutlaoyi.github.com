<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>老逸的个人站</title><link href="/" rel="alternate"></link><link href="http://www.scutlaoyi.tk/feeds/cpp.atom.xml" rel="self"></link><id>/</id><updated>2014-02-16T21:30:00+08:00</updated><entry><title>C++学习(四)：线性表的奇技淫巧(二)</title><link href="/CppLearning004.html" rel="alternate"></link><updated>2014-02-16T21:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-02-16:CppLearning004.html</id><summary type="html">&lt;p&gt;这两天去玩了，
进度比较慢。&lt;/p&gt;
&lt;p&gt;无序线性表终于算是搞了个大概，
有些过于繁琐的就没有管了。&lt;/p&gt;
&lt;p&gt;准备入手有序线性表，
把一些牛逼的算法也弄进去，
二分、堆排序、归并排序什么的。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;奇技淫巧大收集（续）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线性表判环&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就是判别一个线性表中有没有出现环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单标记方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几种标记都可以。&lt;/p&gt;
&lt;p&gt;如果是不重复的整数并且范围比较小的话，
直接开个bool型的数组，用下标表示某个特定的数，
对应值为1指定该值出现过，
对应值为0指定该值没有出现。&lt;/p&gt;
&lt;p&gt;整数下标的数组搞不定则可以考虑弄个标准库的哈希表。&lt;/p&gt;
&lt;p&gt;总之，思路就是遍历链表，
把出现过的标记起来，
当遍历过程中再次碰到被标记过的节点说明链表有环，
否则肯定能搜索到链表的表尾并结束。&lt;/p&gt;
&lt;p&gt;需要一些额外的空间及计算量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Floyd方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感觉搞数学的家伙总能找到一些神奇的方法解决某些奇怪的问题。&lt;/p&gt;
&lt;p&gt;开两个指针fast, slow，均初始化为头节点，
fast每次移动两个节点，slow每次移动一个节点。&lt;/p&gt;
&lt;p&gt;单步运行，直到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、fast指针到达表尾，无环；&lt;/p&gt;
&lt;p&gt;2、fast指针与slow指针在某一步指向同一个节点，有环；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;线性表除环&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单办法就直观了，
直接每个节点检查，
很蠢，不详谈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高效方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，用上述的Floyd算法找到环，
这个时候fast指针(或者slow指针)肯定是在环里面的某个节点。&lt;/p&gt;
&lt;p&gt;利用这个特性，统计，用指针移动统计环中节点的个数，假定为n。&lt;/p&gt;
&lt;p&gt;显而易见，
环的出现肯定是在链表的尾部，
因此去除环相当于将链表的尾节点与环中的连接节点切断。&lt;/p&gt;
&lt;p&gt;那么尾节点现在与哪个节点相连呢？
明显是倒数第n个，因为环有n个节点。&lt;/p&gt;
&lt;p&gt;再利用上一篇博文讲过的从头指针查找倒数第n个节点的办法，
加以变通，
当两个指针在某次移动中指向同一个节点的时候，
说明那里是环的入口。&lt;/p&gt;
&lt;p&gt;接下去就简单了，找到入口就找到了尾节点，
把它的next赋值为0即可搞定。&lt;/p&gt;
&lt;p&gt;太麻烦了博主就没实现... -_-&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;逆向输出&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不同于直接逆向链表，
这个只是逆向输出所有值，链表本身没有变化。&lt;/p&gt;
&lt;p&gt;方案其实不复杂，
递归嘛，谁不会。&lt;/p&gt;
&lt;p&gt;实现的时候偷懒，
不想搞两个函数一个内部递归一个外部调用，
因此用了一个默认参数0给curptr初始值，
外部调用时只传入第一个函数指针用于输出。&lt;/p&gt;
&lt;p&gt;检测到节点指针为0说明是外部第一次调用，
指针初始化为头节点。&lt;/p&gt;
&lt;p&gt;否则说明是递归过程，
则做对应处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;listprintreverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;curptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;listprintreverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;listprintreverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;旋转链表&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以某个节点旋转链表，
比如1-2-3-4-5,
以节点2旋转，则变成3-4-5-1-2&lt;/p&gt;
&lt;p&gt;用链表实现这货就非常简单啦，
头尾指针处理一下即可搞定。&lt;/p&gt;
&lt;p&gt;不过要注意边界情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;rotatefrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ind&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_getnth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getend&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;关于输出&lt;/h2&gt;
&lt;p&gt;由于使用了模板，
无法确定节点的值是什么类型，
因此在处理遍历输出的时候就没法在类模板中把输出语句预先定义死。&lt;/p&gt;
&lt;p&gt;使用函数指针解决这个问题，
从外部传入输出特定类型节点值的函数，
遍历函数直接调用外部传入的函数进行最终的输出工作。&lt;/p&gt;
&lt;p&gt;第一次使用C++的函数指针，还是蛮好玩的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;listprint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;nodeprinter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category></entry><entry><title>C++学习(三)：线性表的奇技淫巧(一)</title><link href="/CppLearning003.html" rel="alternate"></link><updated>2014-02-11T21:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-02-11:CppLearning003.html</id><summary type="html">&lt;p&gt;在Github上建了一个新仓库练习数据结构，
地址在这里：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="https://github.com/scutLaoYi/data-structure"&gt;https://github.com/scutLaoYi/data-structure&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;clone的话记得在后面加.git后缀(没什么好clone的)。&lt;/p&gt;
&lt;p&gt;我觉得莫名其妙的是代码类型居然被判为57%的C、25%的C++，
以及18%的Objective-C。&lt;/p&gt;
&lt;p&gt;学习的资料上一篇博文已经说过了，是个好地方。&lt;/p&gt;
&lt;p&gt;从线性表学起，实现了资料里说的一些问题，
光看不写的话感觉倒是容易看懂，不过真的写起来总是一大堆问题。&lt;/p&gt;
&lt;p&gt;上哪都一样。&lt;/p&gt;
&lt;p&gt;线性表才看了一半不到，
总结一下自己用的一些实现方法及若干这几天见到的牛逼技术。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;数据结构的实现&lt;/h2&gt;
&lt;p&gt;自己的实现方案使用了类模板，
首先定义了一个节点的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;包含一个节点值及一个指向下一个节点的指针。
构造函数用于初始化指针，赋值为0。&lt;/p&gt;
&lt;p&gt;然后搞了一个freelist用于处理内存。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Freelist&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="n"&gt;Freelist&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Freelist&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;*&lt;/span&gt; &lt;span class="n"&gt;newnode&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;delnode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个搞法是以前学习数据结构大作业的时候了解到的，
delete和new的效率比较低，
因此自定义了节点的申请和释放，
用一个自由链表储存所有闲置的节点，
当某个节点被删除的时候暂存到自由链表里，
当需要新节点的时候先去看有没有空闲的，
没有再new新的节点。&lt;/p&gt;
&lt;p&gt;带来的坏处是内存的占用会比较大。&lt;/p&gt;
&lt;p&gt;在此基础上开始构建线性表。&lt;/p&gt;
&lt;p&gt;此外需要注意的是类模板的实现问题，
以前也遇到过结果时间长了又给忘了。
简单说来不能把template的实现放在cpp文件中，
不然编译的时候会出现符号错误。
最方便的处理方式是把实现贴到头文件的下面去，
去掉cpp文件。&lt;/p&gt;
&lt;p&gt;我记得不同编译器对这个问题的解决方案有些差异，
以前用VC++编译器的时候是在需要使用模板的文件里，
把cpp文件也include进去。
不过这种做法在g++里貌似搞不定，
最终把东西都扔进头文件里了事。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;线性表&lt;/h2&gt;
&lt;p&gt;类的结构倒是非常简单，
搞一个自由链表用于处理节点，
保存一个头节点的指针即可。&lt;/p&gt;
&lt;p&gt;博主的搞法是用一个空值的节点作为头节点，
头节点的nex指针指向第一个有值的节点，
如果链表为空的话头节点的nex指向null。
与教学材料中的不同，
这种搞法的好处是头节点将永远存在，
因此少了非常多的特判，
也不容易出错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Linklist&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Freelist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;freelist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现了几个私有的函数用于处理常见的操作，
简化代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step步进函数，
让指针指向自身的nex，
返回布尔值指示结果。&lt;/p&gt;
&lt;p&gt;其他的还包括getend函数获取链表尾节点，
_getnth函数获取某个特定的节点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;奇技淫巧大收集&lt;/h2&gt;
&lt;p&gt;接下来就是若干特定问题处理的收获了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取链表中间位置值&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题在数组里非常容易处理，
直接长度的一半去偏移头指针即可。&lt;/p&gt;
&lt;p&gt;但是在没有保存链表长度的线性表中就比较麻烦，
因为不知道长度所以没有办法知道哪一个是链表中间位置的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单方案非常直观，
首先遍历链表，数一遍知道链表总长度，
算出中间位置是哪个，
然后再遍历链表到中间位置即可。&lt;/p&gt;
&lt;p&gt;简单方案感觉有点蠢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高效方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个指针，均从头节点开始，
一个快的指针每次移动两个节点，
一个慢的指针每次移动一个节点。&lt;/p&gt;
&lt;p&gt;当快的指针移动到链表尾部的时候，
慢的指针刚好就在链表的二分之一的位置。&lt;/p&gt;
&lt;p&gt;要多考虑一些边界情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;getmiddle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;slow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;fast&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;slow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;slow&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;fast&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;slow&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;获取倒数第n个节点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同样，数组的话算一下偏移量直接就出来了。
对于没有长度记录的线性表还是难搞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样是先遍历一遍数长度，
得到长度后再找到目标节点。
根据长度判一下有没有倒数第n个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高效方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是两个指针，
一个在头，
一个在头指针后n个节点的位置。&lt;/p&gt;
&lt;p&gt;同时移动两个指针，每次一个节点，
直到后面那个指针到达线性表的尾部，
此时前面的指针就指向了倒数第n个节点。&lt;/p&gt;
&lt;p&gt;如果一开始就没办法移动到第n个位置则说明线性表没那么长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;getnthfromend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mainptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;referptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;mainptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;_getnth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;referptr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;referptr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mainptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mainptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;反转链表&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就是整个反过来，
数组的话有多种方案可以搞，
比如搞个缓冲区，
两个指针分别从头尾向中间移动，
每次交换两个指针的值，
那么可以交换n/2次，占用额外一个空间搞定。&lt;/p&gt;
&lt;p&gt;链表的话...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;额外的O(n)空间作缓冲区，
遍历一遍原链表，
把内容暂存到缓冲区中，
再遍历一遍链表把内容反向刷新进去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高效方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建三个指针，
prev, cur, nex。&lt;/p&gt;
&lt;p&gt;直接操每个节点的nex指针，
遍历链表，
每次将cur-&amp;gt;nex赋值给nex，保存下一个需要处理的节点；
将prev赋值给cur-&amp;gt;nex，把当前指针的nex反向指向父节点；
将cur赋值给prev，nex赋值给cur，移动并处理下一个节点。&lt;/p&gt;
&lt;p&gt;最终最后一个节点变成头节点，搞定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Linklist&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//have some more to deal with&lt;/span&gt;
            &lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="c1"&gt;//reach the end of the list&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;nex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写这货还学了一下vim操剪贴板的技术，
研究了有些时日现在终于有比较好的解决方案了，
下次来记录一下。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category></entry><entry><title>C++学习(二)：大家一起来Makefile</title><link href="/CppLearning002.html" rel="alternate"></link><updated>2014-02-08T16:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-02-08:CppLearning002.html</id><summary type="html">&lt;p&gt;由于一直没找到好的材料，C++的学习拖了好几天没什么进展。
主要遇到的问题是白书的题目(UVAoj)有些麻烦，之前刷了十几道水题一直很顺利，
到了数据结构系列突然每道题都有点难以理解（难道是自己英语水平突然掉了...），
刷了几天进展很慢，加上每道题都有针对性的代码，对于我这种目标是复习数据结构的不太合适。&lt;/p&gt;
&lt;p&gt;然后玩了两天JavaScript（每页一句模块实现），玩了一天游戏...&lt;/p&gt;
&lt;p&gt;找到一个好地方学习数据结构：&lt;/p&gt;
&lt;blockquote&gt;
&lt;a class="reference external" href="http://www.geeksforgeeks.org/data-structures/"&gt;http://www.geeksforgeeks.org/data-structures/&lt;/a&gt;&lt;/blockquote&gt;
&lt;p&gt;今天开始敲了一下线性表，过几天再写点总结。&lt;/p&gt;
&lt;p&gt;然后终于到了这篇的主题，makefile的编写。&lt;/p&gt;
&lt;div class="section" id="make"&gt;
&lt;h2&gt;make&lt;/h2&gt;
&lt;p&gt;所谓的make，是便于编译多个文件的工具，用make可以实现自动化构建软件。
同时使用make可以根据依赖关系自动编译，简化手工操作。
具体的介绍可以查一下make的手册页。&lt;/p&gt;
&lt;p&gt;很多的IDE现在都实现了make的功能，
比如之前用过的Visual Studio系列，Code::block，甚至是Qt SDK的开发环境，
只要建立一个工程，就可以让IDE自动完成多文件编译和依赖检查。&lt;/p&gt;
&lt;p&gt;但Linux下的很多软件还是使用make协助软件的部署，
而像博主这种懒得用IDE的家伙，
手头就一个Vim写代码，一个g++编译（写C++的话），
有时用用gdb调试一番（更多时候是暴力调试...)，
再用上方便的make其实也就差不多了。&lt;/p&gt;
&lt;p&gt;开源社区中也有许多软件是用make的，
就像博主这个网站使用的Pelican，
从源文档加载主题文件（CSS，JS等）转换成静态的HTML页面，
这个过程就使用了make，从而省去了大量的重复命令。&lt;/p&gt;
&lt;p&gt;make默认情况下读取当前文件夹中的makefile文件，
makefile相当于配置文件，
指导make执行命令完成目标代码的编译。&lt;/p&gt;
&lt;p&gt;make不限于特定的语言，
博主把它放在C++栏目中是因为历史上很多很多人用make协助编译C/C++代码。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
假设要编译三个文件：main.cpp test.h test.cpp，输出为a.out
那么默认情况下每次要这样写：
g++ main.cpp test.h test.cpp -o a.out
如果写好了makefile，每次只需要这样：
make
并且会自动检查依赖，忽略某些未改变的项，提高编译速度
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;获取make&lt;/h2&gt;
&lt;p&gt;据称很多Linux发行版中都自带了make，
我不知道其他人的是什么情况，
反正博主手头的Arch Linux没有...(=_=)&lt;/p&gt;
&lt;p&gt;不过不要紧，pacman -S装一下就有了，非常方便&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="makefile"&gt;
&lt;h2&gt;makefile文件的编写&lt;/h2&gt;
&lt;p&gt;makefile文件的基本语法如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[target]:[dependencies]
[tab]   command
&lt;/pre&gt;
&lt;p&gt;其中target为目标，调用命令make时指定目标即可实现不同的执行过程。&lt;/p&gt;
&lt;p&gt;dependencies为依赖项，make执行时首先检查对应目标的依赖是否满足，
如果搜索到存在对应的文件，且在上次执行后没有被更改，则认定该项依赖满足，
否则搜索查找对应依赖项的目标并首先执行它，获取目标依赖。
当所有依赖满足后执行最终目标。&lt;/p&gt;
&lt;p&gt;tab就是一个tab制表符。&lt;/p&gt;
&lt;p&gt;command才是最终被执行的命令语句，如&amp;quot;g++ main.cpp -o a.out&amp;quot;之类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个最简单的makefile&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
all:
    g++ main.cpp test.h test.cpp -o a.out -Wall -g
&lt;/pre&gt;
&lt;p&gt;all是默认make的目标。
上面这两行定义了最简单的makefile，将它保存并执行如下语句：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make
&lt;/pre&gt;
&lt;p&gt;make后不加参数，因此make执行makefile文件;
由于没有设定目标，因此选择默认目标all;
由于all目标没有依赖项，因此可以直接执行;
最终那句g++被执行，完成编译（输出a.out，显示警告，添加debug信息用于gdb调试）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多目标带依赖项的makefile&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
all: main

main: main.o test.o
    g++ main.o test.o -o a.out -Wall -g

main.o: main.cpp
    g++ -c main.cpp

test.o: test.cpp test.h
    g++ -c test.h test.cpp
&lt;/pre&gt;
&lt;p&gt;基本上一目了然，
默认目标依赖main目标，
mian目标依赖main.o和test.o，
两个o文件依赖对应的源文件和头文件。&lt;/p&gt;
&lt;p&gt;这种情况下首次执行make，由于所有依赖都不满足，
因此最先被执行的是编译main.cpp，
其次执行编译test.cpp和test.h，
最后编译出a.out。&lt;/p&gt;
&lt;p&gt;而在所有文件都没有变化的情况下再次执行make，
由于两个依赖都存在，
因此只有编译a.out的那句被执行了一次。&lt;/p&gt;
&lt;p&gt;make自动检测文件变化，
因此会自动重新编译被修改过的文件。&lt;/p&gt;
&lt;p&gt;此外，还可以指定make目标以编译部分文件，指定目标的命令如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make main.o
&lt;/pre&gt;
&lt;p&gt;这句指定编译main.o目标。&lt;/p&gt;
&lt;p&gt;如果目标已经存在并且是最新，则make会提示：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make: 'main.o' is up to date.
&lt;/pre&gt;
&lt;p&gt;插句话，-o选项让g++编译并不链接文件，生成的文件为原文件名替换上.o后缀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带参数和注释的makefile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在makefile中指定参数，
同时可以写注释。&lt;/p&gt;
&lt;p&gt;感觉比较简单，贴个例子就可以了：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#这是注释，用井号开头就可以了
#声明参数要像下面这样
OUTPUT=a.out
#使用的话是这样：

all:
    g++ main.cpp -o $(OUTPUT) -Wall -g
&lt;/pre&gt;
&lt;p&gt;上面的例子就定义了输出文件名参数，
这样在多个地方都可以通过“钱+小括号”的形式使用参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不想用makefile做文件名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随便搞，只要在make的时候麻烦一点给个参数指定文件名即可：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make -f my_makefile
&lt;/pre&gt;
&lt;p&gt;使用my_makefile文件作为配置文件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;make的各种功能&lt;/h2&gt;
&lt;p&gt;学会写makefile之后应该能够看出来，
make其实是通过构造shell命令执行功能的，
因此发挥想象力，用make可以搞定非常多的东西。&lt;/p&gt;
&lt;p&gt;一个非常简单的例子是自动清空当前文件夹的编译过程文件：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
all:
#......

clean:
    rm -rf *.o *.gch
&lt;/pre&gt;
&lt;p&gt;这样，执行&lt;/p&gt;
&lt;pre class="literal-block"&gt;
make clean
&lt;/pre&gt;
&lt;p&gt;即可搞定清扫工作。&lt;/p&gt;
&lt;p&gt;当然&amp;quot;rm -rf&amp;quot;是比较狠的，使用要小心。&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category></entry><entry><title>C++学习(一):白书基础总结</title><link href="/CppLearning001.html" rel="alternate"></link><updated>2014-01-31T16:30:00+08:00</updated><author><name>laoyi</name></author><id>tag:,2014-01-31:CppLearning001.html</id><summary type="html">&lt;p&gt;装完Arch Linux最近开始复习一下C++和数据结构，为下学期做好准备。&lt;/p&gt;
&lt;p&gt;用白书刷一些简单的题目复习基本语法，发现自己太不注重基本的东西了，之前瞎搞ACM的时候也是，好多方便有效的工具都不认识。&lt;/p&gt;
&lt;p&gt;因此记录一下标准库的一些基本的工具和输入输出的简单总结。&lt;/p&gt;
&lt;p&gt;本篇主要记录一些C语言的常用工具。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;输入输出及文件操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;scanf&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这货读取输入并对相应的内存地址赋值。
分割符是空格、回车及制表符等。&lt;/p&gt;
&lt;p&gt;返回值是一个整型表示成功读取到的数据量。
读取失败或者EOF文件结束都会停止。&lt;/p&gt;
&lt;p&gt;默认情况下scanf不会吃掉行尾的回车，
需要让它吃掉行尾回车的话可以这样：&lt;/p&gt;
&lt;p&gt;scanf(&amp;quot;%d\n&amp;quot;, &amp;amp;num)&lt;/p&gt;
&lt;p&gt;上面这句首先读了一个整型值给变量num，并且吃掉了后面的一个\n&lt;/p&gt;
&lt;p&gt;当然这种搞法的缺陷在于只能用于Linux类型系统，
因为windows和Mac OS的回车符都不一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;sscanf/fscanf&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;scanf的姊妹版本，分别读取字符串或者文件。&lt;/p&gt;
&lt;p&gt;sscanf使用的时候加入第一个参数指定输入的源字符串。&lt;/p&gt;
&lt;p&gt;fscanf使用的时候加入第一个参数指定输入的源文件指针。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;fgets(buffer, size, source)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从输入源source中读入一行字符数据到buffer缓冲区中，最大长度为size。
超过size部分会被忽略。&lt;/p&gt;
&lt;p&gt;buffer为一个char数组，size为整型值定义长度。&lt;/p&gt;
&lt;p&gt;source可以为文件等，默认的终端标准输入(standard input)是这个： stdin&lt;/p&gt;
&lt;p&gt;fgets与scanf混用的话由于scanf默认不吃掉行尾回车，会导致scanf之后fgets第一行没有内容。
处理方法就是上面说的改进版本scanf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;fgetc(source)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从source中读取一个字符并返回。
注意返回值是int。&lt;/p&gt;
&lt;p&gt;使用fgetc需要检查返回值不是EOF，然后再转换为char获取得到的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;重定向版本的文件操作&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从文件读取数据可以使用多种方法，
最简单的是输入重定向，
将stdin指向文件。&lt;/p&gt;
&lt;p&gt;一、&lt;/p&gt;
&lt;p&gt;freopen(&amp;quot;filename&amp;quot;, &amp;quot;r&amp;quot;, stdin);&lt;/p&gt;
&lt;p&gt;将filename文件以读(r)方式打开，并重定向到stdin中。
后续的操作便可以直接scanf搞定。&lt;/p&gt;
&lt;p&gt;同样，输出也可以这么搞：&lt;/p&gt;
&lt;p&gt;freopen(&amp;quot;outputfilename&amp;quot;, &amp;quot;w&amp;quot;, stdout);&lt;/p&gt;
&lt;p&gt;二、&lt;/p&gt;
&lt;p&gt;此外，白书没有说的一种方式是直接在终端里运行程序的时候重定向。&lt;/p&gt;
&lt;p&gt;./a.out &amp;lt; data &amp;gt; out&lt;/p&gt;
&lt;p&gt;其中a.out是可执行文件，利用&amp;lt;将data数据文件作为输入，利用&amp;gt;将输出重定向到out文件&lt;/p&gt;
&lt;p&gt;这种搞法的好处是随时可以指定输入输出，不用重新编译。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文件流版本的文件操作&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准的文件操作，包含打开文件、操作文件和关闭文件。&lt;/p&gt;
&lt;p&gt;FILE * fin = fopen(&amp;quot;filename&amp;quot;, &amp;quot;mode&amp;quot;)&lt;/p&gt;
&lt;p&gt;打开filename文件，mode可以为r或者w，加上b的话貌似是二进制方式操作。
返回值是一个FILE *类型的指针，指向打开的文件。&lt;/p&gt;
&lt;p&gt;用fscanf替换scanf，添加第一个参数指定输入的文件指针，例如：&lt;/p&gt;
&lt;p&gt;fscanf(fin, &amp;quot;%d&amp;quot;, &amp;amp;num)&lt;/p&gt;
&lt;p&gt;从fin这个FILE *中读取一个整型值给num变量&lt;/p&gt;
&lt;p&gt;fgets的话直接就可以用了：&lt;/p&gt;
&lt;p&gt;fgets(buf, size, fin)&lt;/p&gt;
&lt;p&gt;最后记得关闭文件&lt;/p&gt;
&lt;p&gt;fclose(fin)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;printf/sprintf/fprintf&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
相当那个scanf三兄弟，不再赘述。&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;标准库的一些方便的工具&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;cstring&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串一类的操作就不用说了，strcmp啦strcpy啦strcat啦都非常方便。&lt;/p&gt;
&lt;p&gt;此外strstr返回目标串中某子串最早出现位置的指针，有时能有奇效。&lt;/p&gt;
&lt;p&gt;这里主要想记录的是两个内存操作的工具：&lt;/p&gt;
&lt;p&gt;memset(void *ptr, int value, size_t size)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查了相关的资料，memset是按字节操作的，虽然传入的value是一个int，
但处理的时候会被转换成unsigned char进行赋值。&lt;/p&gt;
&lt;p&gt;因此处理字符数组是没有问题的，比如给一个字符数组刷二十个字符'a':&lt;/p&gt;
&lt;blockquote&gt;
memset(target, 'a', 20)&lt;/blockquote&gt;
&lt;p&gt;但是处理数字的时候就存在问题了，例如常用的int占四个字节，照着原理来讲0或者-1是可以的。
因为按照数字的储存方式（补码）来说，0的话所有位都是0，-1的话所有位都是1，
刚好绕过了int与byte之间的大小区别。
因此可以用memset刷int型数组：&lt;/p&gt;
&lt;blockquote&gt;
memset(numAry, 0, sizeof(numAry)) //将数组的所有元素刷成0&lt;/blockquote&gt;
&lt;p&gt;这里就需要注意刷的内存块的大小，
因为是按字节操作，因此总的大小应该是每个int的大小(sizeof(int))乘上需要刷的元素个数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;memcpy(void *dis, void *source, size_t size)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;仍然是按字节操作，
从source指针指向的地址开始，
将size个字节复制，
存储到从dis指向的地址开始的后size个字节。&lt;/p&gt;
&lt;p&gt;由于这货直接操某块内存，因此不仅能用于复制数组：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
int ary1[] = {1,2,3,4,5};
int ary2[5];
memcpy(ary2, ary1, sizeof(int) * 5);
&lt;/pre&gt;
&lt;p&gt;还能直接搞结构体：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
struct MyStr{
    int num,
    char str[100]
};
MyStr str1, str2;
//...
memcpy(&amp;amp;str2, &amp;amp;str1, sizeof(str1));
&lt;/pre&gt;
&lt;p&gt;注意要取址符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;cctype&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这货非常方便，拥有一堆检测的库函数。&lt;/p&gt;
&lt;p&gt;常用的有以下几个：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
isdigit:检测是否数字
isalpha:检测是否字母（含大小写）
isupper:检测是否大写字母
islower:检测是否小写字母
&lt;/pre&gt;
&lt;p&gt;还有俩牛逼的货色：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
toupper:将字母转换成大写
tolower:将字母转换成小写
&lt;/pre&gt;
&lt;p&gt;博主比较懒，有时不检测就直接tolower操数据，
发现这货健壮性很好，数字什么的进去也就原样出来，不会死掉，方便！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;cstdio&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面说的输入输出基本都是这个库的东西。&lt;/p&gt;
&lt;p&gt;此外还有一个有用的函数：&lt;/p&gt;
&lt;blockquote&gt;
feof(source)&lt;/blockquote&gt;
&lt;p&gt;检测source源是否为EOF状态。
source可以是文件指针也可以是stdin。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;cstdlib&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个用得多的是快排：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void qsort (void* base, size_t num, size_t size,
        int (*compar)(const void*,const void*));
&lt;/pre&gt;
&lt;p&gt;然后在写这篇博文的时候发现居然还有这个：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
void* bsearch (const void* key, const void* base,
               size_t num, size_t size,
              int (*compar)(const void*,const void*));
&lt;/pre&gt;
&lt;p&gt;随机数，常用的，先用时间作为随机种子，然后用库函数获取随机值：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
//首先需要包含ctime头文件
//然后将当前时间作为随机种子
srand(time(NULL));
//获取一个小于100的随机值
int randVal = rand() % 100
&lt;/pre&gt;
&lt;p&gt;rand函数随机值的范围与库的实现有关，但可以保证最小值为0，最大值不小于32767的整数&lt;/p&gt;
&lt;p&gt;越看越神奇，还有一堆字符串转换的函数，以后处理字符串都调标准库算了：
atoi, atof, atol......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好多东西，记多也记不住，还是要多在实践中应用。&lt;/p&gt;
&lt;p&gt;发现写博客的好处在于,当你要讲明白一个东西时，要花更多的时间去搞清楚这货的各个方面。
有时第一次使用的时候只是知道能这么用，但在写博客的时候却要弄清楚更深入一些的原理。
既有助于加深理解，也有助于整理思路。&lt;/p&gt;
&lt;p&gt;不过博主整天只会写一些基础学习，东拼西凑再随便写点个人理解～ (=_=)&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;最后，大年初一，大家新年快乐！ (^_^)&lt;/p&gt;
&lt;/div&gt;
</summary><category term="C/C++"></category></entry></feed>